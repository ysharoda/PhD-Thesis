\chapter{The Exporter}
\label{ch:export}

%So far we have been working in a simplistic dependent language. The next step is to export our work in Tog into systems that are widely used for theory development and proofs. We start with Agda, as it is the one that resembles Tog the most. 

Generating the definitions of constructions from a theory presentation saves a lot of library development time, but having these definitions in a feature-rich language makes it even more useful. In this chapter we implement an automatic translator of the library theories and their related constructions to agda and lean. This part is related to the third research question from Section~\ref{sec:questions}. 
%and lean\ednote{lean is still being implemented} 

In Section~\ref{sec:exporting_agda} we describe the exporter implemented in haskell. Many parts of this exporter are straight forward translations between the two syntax trees. Nevertheless, there were some challenges that we discuss in Section~\ref{sec:exporting:challenges}. We compare our generated agda code to the one in the agda standard library~\cite{agda_stdlib} and discuss how close we can get to the standard library presentation in Section~\ref{sec:compasion_agda_stdlib}. 
%To assess how our approach scale up, we discuss how we extended the exporter to support lean, as a target language, in Section~\ref{sec:exporting_lean}. 
We wrap the by a discussion in Section~\ref{sec:exporting:discussion}. 

\begin{comment}
One of the problems we highlight here is how design decisions lead to different presentations of the same theory, forcing developers to rewrite the same mathematical knowledge in different ways. In this chapter, we investigate the following question
\begin{itemize}
\item Given the tog abstract representation, can we export to formal systems with more complex meta theory and design decision. 
\end{itemize}
\end{comment}

\section{Exporting to Agda and Lean}
\label{sec:exporting_agda}
The tog definitions have all the information needed to mathematically present the concepts they are describing. The process of exporting these definitions from tog to agda or lean can be seen as \emph{presenting} them in a way that the target language understands (type checks). The type class, \lstmath{Export}, takes care of that. It prints the tog definitions in a form accepted by the target language, whose type checker is then called on them. 
\begin{hscode}
class Export a where
  export :: Config -> a -> Doc  
\end{hscode}
For every type in the tog AST, presented in Figure~\ref{fig:togRepr}, we create an instance for the \lstmath{Export} class. The \lstmath{Config} type is used to describe the configuration of each language. It contains details about language specific properties or pieces of syntax. 
We use the Haskell pretty printer provided by \lstmath{Text.PrettyPrint.Leijen}, which is an implementation of the pretty printer described in~\cite{wadler2003prettier}. 

\subsection{Background}
In~\cite{wadler2003prettier}, an algebra for defining pretty printers is introduced, based on $6$ primitives 
\begin{hscode}
(<>) :: Doc -> Doc -> Doc 
empty  :: Doc 
text :: String -> Doc 
line :: Doc 
nest :: Int -> Doc -> Doc 
layout :: Doc -> String 
\end{hscode}
Where \lstmath{Doc} is the type of a document. The \lstmath{(<>)} operation concatenates two documents. It is an associative operation with \lstmath{empty} being its right and left unit\footnote{\cite{wadler2003prettier} refers to \lstmath{empty} as \lstmath{nil}}. 
%\begin{comment}
On top of these primitives, we have used the following functions provided by the 
\lstmath{Text.PrettyPrint.Leijen}. 
\begin{itemize}
\item \lstmath{(<+>)} : concatenates two \lstmath{Doc} instances with a space between them. 
\item \lstmath{(<$\$$>)} : concatenates two \lstmath{Doc} instances with a \lstmath{line} in between them. 
\end{itemize}
%\end{comment}

\subsection{The Exporter}
We present here some of the interesting instances of the \lstmath{Export} type class~\footnote{The full code is available at: \url{https://github.com/ysharoda/Deriving-Definitions/blob/7e19c3c7d6240d7ff228a91c6c32d1914c483195/src/Tog/Exporting/export.hs}}. 
Our generator defines every theory along with its generated constructions in a  \lstmath{Module}. Exporting a \lstmath{Module} is described by the following instance 
\begin{hscode} 
instance Export Module where
  export conf (Module nm params decls) =
    export conf imprts <$$>
    text (m1 conf) <+> export conf nm <+> text (m2 conf) <+> 
    export conf params <+> text (m3 conf (isEmpty decls)) <$$>
    (indent 2 $ export conf defs) <$$>
    moduleEnd conf nm 
    where (imprts,defs) = split conf decls
          isEmpty (Decl_ []) = True
          isEmpty _ = False 
\end{hscode} 
The exporter is parameterized over the keywords that a language use. In order to use the same exporter for $2$ different language, we had to observe their differences and parameterize over them. The general structure of a module in agda and lean is 
\begin{lstlisting}[mathescape]
            m1 nm m2 params m3
            ...
            m4
\end{lstlisting}
In agda, \lstmath{m1} is \lstmath{module} and \lstmath{m3} is \lstmath{where}, while in lean they have the values \lstmath{section} and empty. The \stmath{export} function reads these values of the configuration. Agda and lean also differ in the position of imports. In lean imports are declared before opening the module (section), while in agda they can be declared inside or outside the module\footnote{In agda, the position of the imports determined their scope.}. The decision of where to place the imports is part of the configuration. The \lstmath{split} function reads this parameter and either return the list of imports to be declared outside the module or empty. 

The variables \lstmath{module_} and \lstmath{module_beforeDecls} stands for the keywords \lstmath{module} and \lstmath{where} used when defining a new module in agda. The function \lstmath{printAgda} is used to call the exporter over the constructor parameters. 

The parameters of a module are represented as \lstmath{[Binding]}, which can be hidden or explicit. Exporting the binding is done as follows 
\begin{hscode}
instance PrintAgda Binding where
  printAgda binds =
    let arguments as = foldr (<+>) empty $ map (printAgda) as
        binding x =  arguments (getBindingArgs x) 
                     <+> text ofType 
                     <+> printAgda (getBindingExpr x) 
    in case binds of
      Bind  _ _ -> parens $ binding binds
      HBind _ _ -> braces $ binding binds
\end{hscode}
The body of the module consists of declarations \lstmath{[Decl]}, which are exported as follows 
\begin{hscode}
instance PrintAgda Decl where
  printAgda (TypeSig typ) = printAgda typ
  printAgda (FunDef nm patterns body) =
    printAgda nm 
    <+> (foldr (<+>) empty $ map (printAgda) patterns) 
    <+> text fundef 
    <+> printAgda body
  printAgda (Data nm params body) =
    (text type_keyword) <+> printAgda nm 
    <+> printAgda params <+> printAgda body <+> linebreak 
  printAgda (Record nm params body) =
    (text record_keyword) <+> printAgda nm <+> printAgda params 
    <+> printAgda body <+> linebreak  
  printAgda (Open imp) = text open <+> printAgda imp
  printAgda (Import imp) = text import_ <+> printAgda imp
  printAgda (OpenImport imp) = text open_import <+> printAgda imp
  printAgda (Module_ m) = 
    linebreak <+> printAgda (addOpenDecl m)  <+> linebreak 
  printAgda _ = empty
\end{hscode}
With instances of \lstmath{PrintAgda} for every type in the tog abstract syntax, a single call to \lstmath{printAgda} on the top level module of the tog library generates the equivalent agda definitions\footnote{the generated files available at:\url{https://github.com/ysharoda/tog/tree/master/Library/generated}}.

\section{Challenges}
\label{sec:exporting:challenges}
The \lstmath{PrintAgda} type class gives us the direct translation between tog and agda. Tog is an experimental minimal implementation of Martin-l\"{o}f type theory. There are some features present in agda that tog does not support, and therefore some adjustments of the syntax is needed. We discuss these adjustments in this section. 

\subsection{Universes}
Tog provides only one kind \lstmath{Set}. It does not support universes, and so \lstmath{Set : Set}. On the other hand, agda has an infinite number of universes, and so 
\lstmath{Set$_{n}$ : Set$_{n+1}$} for any natural number $n$. 
All the constructions we generate belong to the same level, except for relational interpretations, which describe a structure-preserving relation between two instances of the theoy, see Section~\ref{sec:generation:relInterp}. In tog, relational interpretations are records and the relation is a field of the record represented as 
\begin{togcode}
interp : A1 -> A2 -> Set
\end{togcode}
for types \lstmath{A1} and \lstmath{A2}, which are carriers of the two instances. 
A record with this field in tog has a type \lstmath{Set}. When exported to agda, it needs to have the type \lstmath{Set$_{1}$}. 

To solve the universes problem, we provide the function \lstmath{universeLevel} which checks the fields of a record for a \lstmath{Set} type. If it finds one, it sets the type of the record to \lstmath{Set$_{1}$}. 
\begin{hscode}
universeLevel :: Fields -> Doc
universeLevel flds =
  text ~$\$$~
    if elem "Set" ~$\$$~ everything (++) (mkQ [] (\ (Name (_,x)) -> [x])) flds
    then "Set$_1$" else "Set" 
\end{hscode}
\ednote{something wrong with the subscript in the then part} 
The function \lstmath{universeLevel} is called every time a record header is printed. 

\subsection{The Prelude}
The constructions we generate from theory presentations depend on tog definition of \lstmath{Nat}, \lstmath{Fin}, lstmath{Vec}, and \lstmath{lookup}. Tog does not support indexed types and defines \lstmath{Fin} as  
\begin{togcode}
data Fin (n : Nat) : Set where
  fzero : (m : Nat) (p : n == suc m) -> Fin n
  fsuc  : (m : Nat) (p : n == suc m) (i : Fin m) -> Fin n
\end{togcode}
This leads to a rather complicated definition of the \lstmath{lookup} function. 

On the other hand, agda supports indexed types, has a simpler definition of \lstmath{Fin} and \lstmath{lookup}, and has these definitions in its standard library. Accordingly, we deal with exporting the prelude definitions in a way different than the generated code. 

We provide boolean variables \lstmath{includeX} where \lstmath{X} is replaced by the name of the definition in tog prelude; For the \lstmath{Fin} type this will be \lstmath{includeFin}. The boolean variable decides whether the tog definition of \lstmath{X} is to be exported or not. Definitions that are not exported need to exist in the list of \lstmath{importNames} that has the names of the modules to be imported by the exporter. 
\begin{hscode}
importNames :: [String]
importNames =
  ["Agda.Builtin.Equality",
   "Agda.Builtin.Nat",
   "Data.Fin", 
   "Data.Vec"]
\end{hscode}
The exporter adds these imports to the module in their expected position.  
\begin{hscode}
agdaModuleWithImports (Module_ (Module nm prms (Decl_ defs))) imprts =
  let importDecls = 
      map (\str -> OpenImport (ImportNoArgs (mkQName str))) imprts 
  in Module_ (Module nm prms (Decl_ (importDecls ++ defs)))
\end{hscode} 

\begin{comment}
In agda, \lstmath{Fin} is defined as 
\begin{agdacode}
data Fin : ~$\mathbb{N}$~ ~$\rightarrow$~ Set where
zero : {n : ~$\mathbb{N}$~} ~$\rightarrow$~ Fin (suc n)
suc  : {n : ~$\mathbb{N}$~} (i : Fin n) ~$\rightarrow$~ Fin (suc n)
\end{agdacode}
\end{comment} 
When importing functions, the order of their inputs may be different than that used when calling the same function in tog. This is the case with the definition of \lstmath{lookup} in agda versus tog where the two arguments are flipped. To solve this problem we provide the \lstmath{callFunc} function to adjust the inputs. 
\begin{hscode}
callFunc :: Expr -> Expr
callFunc a@(App [nm,_,a2,a3]) =
  if (getArgName nm == "lookup") then App [nm,a3,a2] else a
callFunc e = e
\end{hscode}
\lstmath{callFunc} is called before every function is exported. Therefore, it can be easily extended to adjust calls to any function. 

\subsection{Simplifier}
One of the things we generate is a simplifier that uses axioms like \lstmath{e * x $\ \equiv\ $ x} to simplify expressins, see Section~\ref{sec:generation:simplifier}. 
In a theory that has a binary operation with an inverse and a unit, like \lstmath{Group}, a possible axiom is  
\begin{agdacode}
op x (inv x) ~$\equiv$~ e 
\end{agdacode}
which would naturally give rise to a simplification rule. In order for this simplification rule to be accpeted, one needs to compare the two occurences of \lstmath{x} for equality. While tog accepts using the same variable name in pattern matching, and considers the two occurences to be equal, agda would not accept that code. Therefore, we need to have decidable equality to compare the two occurences of variables on the left hand side axiom. This equality can be an extra argument to the function, but as we are seeking uniformity in the generated constructions, we choose to not export these simplification rules. 

\subsection{Field Names}
Another disalignment between tog and agda is related to how they deal with numeric literals. Agda does not accept numbers as names of record fields. 
We provide a function \lstmath{replace} that is called before any \lstmath{Name} is printed. 
\begin{hscode}
replace :: String -> String
replace nm =
  let pieces = splitOn "_" nm
      cond = \x -> if (x == "0" || x == "1") then x ++ ~$_i$~ else x
      postProcess lst = (head lst) : (map ("_"++) ~$\$$~ tail lst)
  in concat ~$\$$~ postProcess ~$\$$~ map cond pieces 
\end{hscode}
A name which is just \lstmath{0} or \lstmath{1} is concatenated with a suffix \lstmath{$_i$}. The suffix is also added if the \lstmath{0} or \lstmath{1} is part of a name, but is separated by \lstmath{_}. This accounts for the naming convention of the MathScheme library for axioms. 

\section{Comparison With Agda Standard Library}
\label{sec:compasion_agda_stdlib}
%Some of the constructions generated in this work is part of the agda standard library and some are not. 
We compare the theories in our framework to the ones in the agda standard library, highlighting how close we can get to them. 
%look at our generated theories and constructions and compare them with the ones that agda provides in its standard library, highlighting how close we can get to them. 

Algebraic structures in agda is a fully bundled telescopes. For example, \lstmath{Monoid} is defined as
\begin{agdacode}
record Monoid c ~$\ell$~ : Set (suc (c ~$\sqcup$~ ~$\ell$~)) where 
  infixl 7 _~$\bullet$~_
  infix 4 _~$\approx$~_
  field 
   Carrier : Set c 
   _~$\approx$~_ : Rel Carrier ~$\ell$~ 
   _~$\bullet$~_ : Op~$_2$~ Carrier 
   isMonoid : IsMonoid _~$\approx$~_ _~$\bullet$~_ ~$\varepsilon$~ 
   
   open IsMonoid isMonoid public
   
   semigroup : Semigroup _ _
   semigroup = record { isSemigroup = isSemigroup }
   
   open Semigroup semigroup public using (rawMagma; magma)
   
   rawMonoid : RawMonoid _ _
   rawMonoid = record { _~$\approx$~_ = _~$\approx$~_; _~$\bullet$~_ = _~$\bullet$~_; ~$\varepsilon$~ = ~$\varepsilon$~}
\end{agdacode}
where every structure is equipped with a predicate that unbundles its carrier and function symbols, while keeping the axioms bundled 
\begin{agdacode}
record IsMonoid (~$\bullet$~ : Op~$_2$~) (~$\varepsilon$~ : A) : Set (a ~$\sqcup$~ ~$\ell$~) where 
  field 
   isSemiring : IsSemiring ~$\bullet$~ 
   identity : Identity ~$\varepsilon$~
     
  open IsSemigroup isSemigroup public
     
  identity~$^l$~ : LeftIdentity ~$\varepsilon$~ ~$\bullet$~ 
  identity~$^l$~ = proj~$_1$~ identity  
  identity~$^r$~ : Rightdentity ~$\varepsilon$~ ~$\bullet$~ 
  identity~$^r$~ = proj~$_2$~ identity           
\end{agdacode}
The flattener described in Chapter~\ref{ch:library} computes flat theories parametereized over the carrier. By comparing the two representations we find that they mainly differ in three aspects that we detail in the following sections. 
\subsection{Predicate Style Presentations}
Starting from flattened theories, we generate the \lstmath{isX} presentation of each theory by adjusting the waist of the theory
\begin{hscode}
isX :: GTheory -> GTheory
isX (GTheory constrs _) =
  let newWaist = length (notAxiom constrs) 
  in GTheory (notAxiom constrs ++ axiom constrs) newWaist
\end{hscode}
The waist of a theory reflects the number of its parameters. The \lstmath{newWaist} is set to be the number of declarations that are not axioms. 

The definition of the theory \lstmath{X} is then changed to include its function symbols, and then make a call to the \lstmath{isX} declaration 
\begin{hscode}
adjustTheory :: Name_ -> GTheory -> GTheory
adjustTheory thryName (GTheory constrs wst) =
  let isXName = "Is"++thryName
      fsyms = notAxiom constrs
      fsymNames = map (\ (Constr (Name (_,nm)) _) -> nm) fsyms
      processName n = if elem n ["+","-","*"] then "("++n++")" else n 
      callIsX = [Constr (mkName ~$\$$~ "is"++thryName)
                     (App ~$\$$~ (mkArg isXName) 
                          : (map (mkArg . processName) fsymNames))]
  in GTheory (fsyms ++ callIsX) wst 
\end{hscode} 
These functions produce the following definitions for \lstmath{Monoid}
\begin{agdacode}
record IsMonoid (A  : Set ) (op  : (A  ~$\to$~ (A ~$\to$~ A ))) (e  : A )  : Set where
  constructor IsMonoidC
  field
   lunit_e : ({x  : A }  ~$\to$~ (op e x ) ~$\equiv$~ x )
   runit_e : ({x  : A }  ~$\to$~ (op x e ) ~$\equiv$~ x )
   associative_op : ({x y z  : A }  ~$\to$~ (op (op x y ) z ) ~$\equiv$~ (op x (op y z ) )) 

record Monoid (A  : Set )  : Set where
  constructor MonoidC
  field
   op : (A  ~$\to$~ (A  ~$\to$~ A ))
   e : A 
   isMonoid : (IsMonoid A op e ) 
\end{agdacode}
There are three main differences between the \lstmath{IsMonoid} in the agda standard library and the one generated here. First, the carrier in the agda library is not a parameter is still in the context, declared as an implicit argument to the parent module. 
Second, the standard library represents axioms as instances of records, like \lstmath{IsSemiring} and \lstmath{Identity}. Automating this introduces a layer of complexity that we discuss in Section~\ref{subsec:agda:modelMorphisms}. The third difference is related to universes. Library definitions are universe polymorphic. Tog does not have universes and all our generated records have the type \lstmath{Set}. 

The record \lstmath{Monoid} have the same differences. Due to the absence of universe support in tog, we prefer to keep the generated \lstmath{Monoid} record parameterized over the carrier. 

\subsection{Setoids Based Presentations}
\label{subsec:setoid-based-pres}
The algebraic hierarchy in agda are defined over setoids, i.e. every carrier set is equipped with its own equality. 
The theory of setoid can be obtained from the \lstmath{Carrier} theory using the extension combinator 
\begin{togcode}
Setoid = extend Carrier {eq : A -> A -> Set}
\end{togcode}
In our development, the equality used to represent the equations is tog's underlying propositional equality. It is part of the meta theory and is not reflected in the theories or the morphisms of the graph. Therefore, switching to a different equality would require doing that on the meta theory level. 

On the other hand, if we start with a graph developed with equality at the theories level, using setoids, one can switch to built in equality by substitution. 


% The data being manipulated in this work is theories in equational logic. The theories of algebra that we consider in this work are first order equational theories, i.e.: all the axioms are equations.

%The problem becomes changing all the axioms to be based on \lstmath{eq} instead of the tog equality. Tog equality is part of the meta thoery, tog, and is not part of any morphism, i.e.: cannot be mapped to \lstmath{eq} to adjust how the axioms look like. \ednote{TBD: how to handle this?}

%On the presentation level, this means that every theory would have one more declaration for the equality, as well as congruence axioms for all its function symbols. 

\subsection{Model Morphisms}\ednote{better name?} 
\label{subsec:model-morph}
\label{subsec:agda:modelMorphisms}
The definition of \lstmath{Monoid} in agda standard library includes model morphisms to  \lstmath{semigroup} definition that given a specific monoid would extract the semigroup structure of it. Our theory presentation does not have this references. The information to generate these model morphisms is present in the theory graph. The graph has a theory presentation morphism between \lstmath{Semigroup} and \lstmath{Monoid}, which triggers a model morphism from \lstmath{Monoid} to \lstmath{Semigroup}. It is worth mentioning that a mechanism to generate model morphisms in our setup will not, in all cases, produce the same model morphisms as the one in the agda standard library. In this case, we are depending on the structure of the graph which is different than the one in agda's library. 

%\section{Exporting to Lean}
%\label{sec:exporting_lean}

\section{Discussion}
\label{sec:exporting:discussion}
The idea of exporting from one language to another has been discussed various times, as we show in Section~\ref{sec:relwork:automation}. Our work take advantage from the fact that we export from a small language, and therefore the source syntax tree is small and can be manipulated easily.  
%Having a minimal source language gives us the opportunity to add design decisions without having to observe how it affects the multiple other features that would be present in a feature-rich language. That makes the export process easier to manage. 

Like in Section~\ref{sec:generation:discussion}, we noted here that some missing features in tog makes the exporting process a bit harder, like universes and indexed types. It is hard to decide which features are needed for a core language that fits our purpose. This is one way our work can be extended. We suggest studying theorem provers as a program family, capturing their commonalities and variabilities via techniques like feature models~\cite{czarnecki2000generative}. If we have this model, one can write a staged exporter to different languages in the model, similar to what is explained in~\cite{stagedConfig}. 

%The theory graph organization structure is useful to add model morphisms has proven useful in the exporting process. The fact that the morphisms carry information about It made it possible to add design decisions, like exporting to the setoids-based graph, and to add the model morphisms as we discussed in Section has also made it possible to incorporate model definitions, as we discuss in Section~\ref{subsec:model-morph}. 

\begin{comment}
Our algorithms generate record definitions, inductive data types and functions. We study how those three constructs look like in Agda. 

\section{Record Definitions}
A record in Tog is has the type \lstmath{Decl} and is created using the \lstmath{Record} constructor as follows 
\begin{hscode}
Record Name Params RecordBody
\end{hscode}
The parameters are either empty or contains \lstmath{[Binding]}, as discussed in \ref{ch:tog}. \lstmath{RecordBody} contains information about the kind of the record, its constructor, and the fields it contains. A simplified view of the fields is \lstmath{[Constr]}. 

A record in Agda consists of 
\begin{itemize}
\item the keyword \lstmath{record}
\item the name of the type 
\item list of parameters surrounded by parenthesis  
\item A semicolon that seperates the name and params from the type 
\item the keyword \lstmath{where}
\item 
\end{itemize}
\end{comment}


