\chapter{A Library of Algebraic Structures}
\label{ch:library}
%One can define a new theory either by stating its components or by using combinators to build it from existing ones. 

In this Chapter, we build a library of axiomatic theories representing the algebraic hierarchy. 
%before we use it to generate related constructions that we discuss in Chapter~\ref{ch:generation}. 
Our library consists of equational first-order theories organized as a theory graph using the tiny theories approach. Instead of having to provide all declaration of the theories and morphisms within the graph, we use the MathScheme combinators introduced in~\cite{CaretteOConnorTPC, carette2018building}. 

It is common to see the algebraic hierarchy as a series of inclusions as in Figure~\ref{fig:flatExtensions}. 
\begin{figure}
\centering{
\begin{tikzcd}
\cn{Magma} \arrow[r, hook] & \cn{Semigroup}\arrow[r, hook] & \cn{Monoid} \arrow[r, hook] & \cn{Group} \arrow[r, hook] & \cdots
\end{tikzcd}}
\caption{Algebraic structures as extensions.}
\label{fig:flatExtensions}
\end{figure}  
But the algebraic hierarchy is richer than that, considering for example the list in~\cite{jipsen}. 
In Section~\ref{sec:background:tinytheories} we discuss tiny theories as an adequate approach to building a theory graph that captures this structure. The nodes of the graph are theory presentations and they are connected via morphisms (see Section~\ref{sec:background:theorygraph}). Morphisms describe how the different theory presentations relate to each other. 
We present the example of building the theory of \lstmath{Unital} by extending the theory of \lstmath{PointedMagma} to create \lstmath{LeftUnital} and \lstmath{RightUnital}, then combining them. This example is described by a diamond structure as in Figure~\ref{fig:unitalDiamond}. 
\begin{figure}
\centering{
\begin{tikzcd} 
& \verb|LeftUnital| \arrow[dr,hook] & \\
\verb|PointedMagma| \arrow[ur,hook] \arrow [dr,hook] & & \verb|Unital| \\
& \verb|RightUnital| \arrow[ur,hook] &
\end{tikzcd}}
\caption{The diamond in the definition of \lstmath{Unital}.}
\label{fig:unitalDiamond}
\end{figure}
The diamond structure appearing in the definition of \lstmath{Unital} is not a special case. Instead, diamonds are pervasive in the algebraic hierarchy, as shown in the theory graph for defining \lstmath{Monoid} in Figure~\ref{fig:cube_monoid}. 
%examining the work in \cite{halleck} and \citeauthors{jipsen} show us that the algebraic %hierarchy is more packed with diamonds, as we show in Figure~
%As we discussed in Section~\ref{sec:thry_graph_in_action}, dealing with diamonds is a challenging problem~\cite{sakkinen1989disciplined, jigsaw1992, traits2006, diamonds2011}. There is a gap in how specification systems handle them, whether by not following its correct semantics, or by not supporting it at all. 

But the diamond structure does not come without problems. We need to have careful infrastructure to deal with them in order to avoid the diamond problem~\cite{jigsaw1992,traits2006,diamonds2011}, a.k.a. multiple inheritance or the fork-join problem~\cite{sakkinen1989disciplined}, which we discuss in Section~\ref{subsec:combine}.

In Section~\ref{sec:thry_graph_in_action} we provide an overview of the support for morphisms in different formal systems. Section~\ref{sec:msCombinators} introduces the MathScheme combinators for a morphism-based approach to building theory graphs, leading to a solution to the diamond problem. We discuss how to use the combinators to build the library in Section~\ref{sec:guidelines}. We end up with Section~\ref{sec:library:discussion} discussing best practice for using the combinators. 

\begin{comment}
To test our generation algorithms, we needed a large library of equational theories. As we have discussed in Section~\ref{sec:broader_context}, we work in the favor of a library organized as a theory graph, believing that it leverages the structure of mathematical knowledge. Morphisms of the graph are the means to relating the different theories. In this section, we present our approach to building a library that emphasizes these connections. 

In Section~\ref{sec:thry_based_libs} we discuss the motivation behind building such a library. In Section~\ref{sec:ms_combinators} we present the combinators used in building it and discuss how they are morphism based. Section~\ref{sec:lib_implementation}, discusses the challenges of the implementation of the combinators to build a theory graph. We finally show some interesting cases of library definitions in Section~\ref{sec:interesting_cases}. 
\end{comment}


\section{Theory Graph Development}
\label{sec:thry_graph_in_action}

Although many formal systems support theory graph structures, more support for using and defining morphisms is needed. 
Specware~\cite{Smith99} and MMT~\cite{MMT} force users to provide all details of theories and morphisms between them. IMPS~\cite{farmer1993imps}, in some cases, generates morphisms given source and target theories. 

%On the other hand, it leads to a multiple diamonds (a.k.a. multiple inheritance) in the development of the hierarchy. 
%Many formal systems support a theory graph approach, and realizes the need of having morphisms between theories. Examples of these are Clear, OBJ, CASL, Maude, Specware, IMPS, and MMT. 

%Clear is - to our knowledge - the first system that provides a modular way to write formal specifications. It provide theory combinators to build larger theories from smaller ones. 
%\ednote{A good resource for Clear is the PhD thesis of Sanella with the title: semantics, implementation and pragmatics of CLEAR} 
Another way to support building a library rich in morphisms is to provide combinators to handle some of the work. Clear~\cite{Goguen1980} is --- to our knowledge --- the first system to use combinators for creating new theories\footnote{Clear is a specification language, and theories are used under the name specifications.}. OBJ~\cite{Obj2000Goguen} and CASL~\cite{CoFI:2004:CASL-RM} are successors of Clear that also support combinators. We focus our discussion on CASL as a representative to these systems, as it is the only living one now and so we were only able to look at its library and run experiments on it. 
We realized two problems related to combinators in CASL. First, it is not always possible to flatten theories built through the use of combinators, especially hiding and freeness combinators~\cite{CoFI:2004:CASL-RM}. The second problem is related to how the \emph{union} operation is implemented. The union operator is the one responsible for combining different specifications. They are combined on a `same name, same thing' basis~\cite{bidoit2003casl}, i.e. two declarations are considered the same if they have the same name. Figure~\ref{fig:casl_expr} shows the problems that occur from using this principle. 
\begin{figure}
\input{figures/casl-exp.tex}
\end{figure}
Both specifications \verb|Ext1| and \verb|Ext2|, on the left side, extend the \verb|BaseSpec| with a binary operation and its unit element. %The semantics of the \lstmath{combine} (or \lstmath{and}) combinator is presented as a pushout in the category of specifications. 
A pushout between the two morphisms \lstmath{BaseSpec $\;\to\;$ Ext1} and \lstmath{BaseSpec $\;\to\;$ Ext2} would result in a theory with one sort, \lstmath{A}, and  two binary operations with two different unit elements. When trying this specification in CASL\footnote{Using the online tool at: \url{http://rest.hets.eu}}, it computes the declarations on the right side of the figure which has only one unit element for the two binary operations. This is different from what a pushout would compute. 

We performed the same experiment with Isabelle locale expressions~\cite{ballarin2003locales} and got similar results. In the following section, we introduce a collection of combinators that provide an infrastructure for building a large library organized as a theory graph that enables us to avoid the problem we have just described. 

\section{MathScheme Combinators}
\label{sec:msCombinators}

Combinators manipulate theories in different ways. They enhance modularity, reusability and maintainability of the library by saving the user the need to repeat definitions. \cite{carette2018building} introduces $4$ combinators based on the definitions of theories as contexts and theory morphisms in dependent type theory as we discussed them in Sections~\ref{sec:background:theory} and \ref{sec:background:morphisms}. %The combinators form a language to create a librarnew theories by reusing older ones. We use this language to build a library of $250$ theories as we discuss in Section~\ref{sec:lib_implementation}. 
%many theorem provers that are in use today, do not have the notion of morphism and suffer from redundancy. Agda and Coq are big examples of that. Apart from extensions, they do not support combining modules.

%In~\cite{carette2018building}, we present $4$ combinators along with their operational and categorical semantics. The semantics we provide is based on the category of contexts and the categorical semantics of dependent type theory. In the following section we present the combinators and their semantics. 

%Despite the large literature on using combinators to save work and reduce redundancy, Most of the systems we listed here suffer from redundancies in their own libraries. \ednote{Add an appendix about the different redundancies}To avoid this redundancy, we suggest in~\cite{carette2018building} a set of combinators that form a compact language to describe algebraic theories by reusing older ones. We use these combinators to build our library as well as some important design decisions 
A library built using these combinators embodies the following design decisions:
\begin{itemize}
    \item Theories can always be flattened. Not all users of a formal system are interested in the hierarchy used to build the theories they need. A mathematician who wants to prove results in \verb|Group| theory is only interested in groups with their standard definitions and results. This user should not be forced to work with groups as extensions of some theory, like \verb|Monoid|. Abstracting over the hierarchy in users' code also has the advantage that the code need not change in case the hierarchy changes, like in the case of changing the type class hierarchy in Haskell~\cite{wiki:haskell_hierarch}. 
    \item Names are taken seriously. Similar concepts have different names in different contexts of mathematics. The unit of \verb|_+_| has a different name than the one of \verb|_*_| and confusing their names would be a huge usability problem. The combinators introduced in~\cite{carette2018building} neither generate any names nor attempt to use any heuristics to solve name clashes. Instead name clashes are detected and the library developer is asked to resolve them.  
    \item Tiny theories are systematically used. Since we do not provide a drop combinator, we use tiny theories to make sure all intermediate results are available for future theories to use. 
    \item Morphisms are the main building unit of the library. The semantics and the implementation of the combinators are based on morphisms, not theories. This makes it possible to compute category-theoretic operations, like union, based on their real semantics, avoiding the need for assumptions like same-name-same-thing. 
\end{itemize}


The combinators assume the underlying logic in which theories are defined to be a dependent type theory (DTT). Therefore, a theory is viewed as a context, or a telescope as defined in equation~\ref{eq:telescope}. But a specific variant of DTT is not assumed; instead many of the details are abstracted away. The minimum requirements of the underlying DTT are listed in ~\cite{carette2018building}. We include them here for convenience and completeness. These requirements are:  
\begin{itemize}
    \item An infinite set $\mathbb{S}$ of symbols.
    
    \item A typing judgement for terms $s$ of type $\sigma$ in a context
    $\Gamma$ which we write as $\Gamma \vdash s : \sigma$.
    
    \item A kinding judgement for types $\sigma$ of kind $\kappa$ in a context
    $\context{\Gamma}$ which we write as \\
    $\context{\Gamma} \vdash \sigma : \kappa : *$.  We further assume that the set
    of valid kinds $\kappa : *$ is given and fixed.
    
    \item A definitional equality (a.k.a. convertibility) judgement of terms
    $s_1$ of type $\sigma_1$ and $s_2$ of type $\sigma_2$ in a context $\context{\Gamma}$,
    which we write as $\context{\Gamma} \vdash s_1 : \sigma_1 \equiv s_2 : \sigma_2$. \ We
    will write $\context{\Gamma} \vdash s_1 \equiv s_2 : \sigma$ to denote $\context{\Gamma} \vdash
    s_1 : \sigma \equiv s_2 : \sigma$.
    
    \item A notion of substitution on terms. Given a list of symbol
    assignments $[x_i \mapsto s_i]_{i < n}$ such that they form a total function, 
    and an expression $e$ we write $\substitutiondef{e}{x_i}{s_i}{i < n}$
    for the term $e$ after simultaneous substitution of symbols $\left\{ x_i
    \right\}_{i < n}$ by the corresponding term in the assignment.
\end{itemize}

We now introduce the combinators we use from~\cite{carette2018building}.  
\subsection{Extension} 
\label{subsec:extension}
Extension is the most basic combinator. On its own, it makes it possible to define a flat hierarchy as in Figure~\ref{fig:flatExtensions}. 

The inputs to an extension combinator are a theory presentation $\Gamma$ and a list\footnote{As we use tiny theories approach, the list always has one declarations. The presentation here is more general and considers finite lists of any size.} of declarations $\extDecls = \left\{a_{i}:\sigma_{i}:\kappa_{i}\right\}_{i<n}$. 
The combinator computes a new theory $\Gamma\rtimes\Delta^+$ and an injective identity morphism (\lstmath{$\tilde{\text{id}}$}) from $\Gamma$ to $\Gamma\rtimes\Delta^+$, where $\rtimes$ is an asymmetric operation that adds definitions to a telescope. On one side $\Gamma$ is a well-formed theory, but $\Delta^+$ may not be well-formed on its own. 
The construction is defined as: 
\[\extensionDef{\extSource}{\extDecls}\]
\noindent where \lstmath{pres} is the theory resulting from the extension and \lstmath{embed} is the identity morphism from the theory being extended to \lstmath{pres}. 

An extension is well-formed if each new symbol $a_i:\sigma_{i}:\kappa_{i}$ in $\Delta^+$ does not occur in $\Gamma_{i-1}$ and its type is well-formed in $\Gamma_{i-1}$, 
where $\Gamma_{i-1} = \Gamma \rtimes \Delta_{i-1}$ and $\Delta_{i-1} \subseteq \Delta^+$ containing the first $i-1$ elements of $\Delta^+$.     
\begin{eqnarray*}
\forall i \cdot a_i \notin \syms{\Gamma_{i-1}} \\
\forall i \cdot \Gamma_{i-1} \vdash \sigma_i : \kappa_{i}
\end{eqnarray*}
where $\Gamma_{i-1} = \Gamma \rtimes \{a_0 : \sigma_0 : \kappa_0\  \cdots \ a_{i-1} : \sigma_{i-1} : \kappa_{i-1}\}$.  

%\paragraph{Categorical Semantics}
%In the category of contexts $\ctxcat$, an extension corresponds to a forgetful functor. 

\paragraph{Example}
Extensions are used when new concepts are added. According to little theories, the concept should be added in its smallest context, i.e. if $\Gamma \vdash c : t$ then for every $\Sigma \subset \Gamma$, $\Sigma \nvdash c : t$. Tiny theories encourages adding one new concept at a time. A good example is adding properties of a binary operation, like \lstmath{commutativity} or \lstmath{associativity} as follows\footnote{The syntax we use here is the one used in our implementation. We give brief explanations for it here, and introduce it in details in the next section.} 
\begin{togcode}
Semigroup = 
  extend Magma {assoc : {x y z : A} ~$\to$~ op x (op y z) == op (op x y) z} 
CommMagma = 
  extend Magma {comm  : {x y : A} ~$\to$~ op x y == op y x}
\end{togcode} 
\noindent where \lstmath{Magma} is the theory $\Gamma$ being extended, \lstmath{assoc} and \lstmath{comm} are definitions in $\Delta^+$. 

\subsection{Rename}
\label{subsec:rename}
A theory is a renaming of another if they contain the same declaration in the same order but with different names for the symbols. A useful use case for rename is obtaining boolean algebras from idempotent ring. Assuming some theorems have been proved for idempotent rings, these theorems still hold for boolean algebras and it would be useful to transport those theorems to boolean algebras without having to prove them again. This can be done if a rename morphism exists between the two theories. Renames allow using flexible notations while still reusing all results from the source theory. 
% https://plato.stanford.edu/entries/boolalg-math/

Given a theory presentation $\Gamma$ and a rename function $\pi$, the output of the rename operation is a new theory, \lstmath{pres}, which is computed by performing a substitution of $\pi$ into the declarations of $\Gamma$, and an embedding morphism $\tilde{\pi} : \Gamma \to \pi\cdot\Gamma$ that maps the symbols of $\Gamma$ to those of $\pi\cdot\Gamma$ based on the renaming function $\pi$. 
\[ \renameDef{\renSource}{\renFun} \]

A rename operation is well-formed whenever the rename function $\pi : |\Gamma| \to \mathbb{S}$ is an injection, and the codomain is a permutation of a subset of $\mathbb{S}$ with exactly $k$ elements, where $k$ is the number of declarations in $\Gamma$. 

\paragraph{Example}
After defining \lstmath{Semigroup} in the example of the previous section over a binary operation \lstmath{op}, one would want to define the additive and multiplicative versions using the symbols \lstmath{+} and \lstmath{*}, resp. It also make sense to have a morphism from \lstmath{Semigroup} to those variants that only differ in the names of the symbols. The rename combinator does just that: 
\begin{togcode}
AddSemigroup  = rename Semigroup {op to +} 
MultSemigroup = rename Semigroup {op to *} 
\end{togcode}  

\subsection{Combine}
\label{subsec:combine}
Conisder the following small library
\begin{togcode} 
Theory Empty = {} 
Carrier = extend Empty {A : Set}
Pointed = extend Carrier {e : A}
Magma   = extend Carrier {op : A -> A -> A}
\end{togcode} 
The flattened version of the theories of these libraries are 
\begin{itemize}
\item[] \lstmath{Empty = []}
\item[] \lstmath{Carrier = [A : Set]}
\item[] \lstmath{Magma = [A : Set, op : A $\;\to\;$ A $\;\to\;$ A]} 
\item[] \lstmath{Pointed = [A : Set, e : A]} 
\end{itemize}
Now we want to define the theory \lstmath{PointedMagma} which has a binary operation and a point. It makes sense to assume this theory to be an extension of both \lstmath{Magma} and \lstmath{Pointed}. Using the extension combinator will not help us here. In this situation, we want a diamond in which our new theory is inheriting from two theories, but it is not clear whether a declaration, for example (\lstmath{A : Set}) should be repeated or not. 
The situation is more complicated if we consider the definition of \lstmath{AdditiveSemigroup} by relating it to \lstmath{AdditiveMagma} defined as 
\begin{togcode} 
AdditiveMagma = rename Magma {op to +} 
\end{togcode} 
\noindent and \lstmath{Semigroup} defined as in Section~\ref{subsec:extension}. Here we have the same binary operation with different names. Which name should be used? Or should they be repeated, having two  binary operations in the outcome? 

The case when a theory needs to be related to more than one ancestor is prevalent when building large libraries. As we see in these examples, it occurs very early on when formalizing the algebraic hierarchy. The combine operation supports the multiple inheritance situation by relying on the information in the morphisms. Combine performs a pushout of the morphisms in the category of theory presentations, i.e. a pullback in the category of contexts.  A pushout is a $5$-ary operation that takes $2$ morphisms and $3$ objects of a category, as explained in Section~\ref{sec:categoryTh}. The morphisms need to originate from the same source. The $3$ theories can be deduced from the morphisms as the two target theories of the morphisms and their common source. For cases where there are name clashes, like the name clash between \lstmath{op} and \lstmath{+} in the \lstmath{AdditiveSemigroup} example, the user is required to provide renames to resolve it. This is consistent with our design decision to not use heuristics or name generation to resolve any name conflicts. 

The two morphisms of the combine operation $u_{\Delta}$ and $u_{\Phi}$ are both injective embeddings, having $\Gamma$ as their source, and having $\Delta$ and $\Phi$, resp, as their targets. 
\[
\comfun\left( u_{\Delta}, u_{\Phi}, \pi_{\Delta}, \pi_{\Phi}\right) \define
\left\{\begin{aligned}
\mathtt{pres} & = \combineResult_0\rtimes\left(\combineResult_{\Delta} \cup \combineResult_{\Phi}\right) \\
\mathtt{embed}_{\Delta} & = \left[v_{\Delta}\right] : \Delta\rightarrow\combineResult\\
\mathtt{embed}_{\Phi} & = \left[v_{\Phi}\right] : \Phi\rightarrow\combineResult\\
\mathtt{diag} & = \left[uv\right]:\Gamma\rightarrow\combineResult\\
\end{aligned}\right\}\]
% ----------------- the removed mediate ----------------- 
% \mathtt{mediate} & = \lambda\ w_{\Delta}\ w_{\Phi}\ .\  w_{\combineResult}
% --------------------------------------------------------
 
%To say a \lstmath{Monoid} is a \lstmath{Semigroup} and a \lstmath{Unital}, we need multiple inheritance, which creates a diamond structure. The \lstmath{Combine} operation is the one to use in this case. 
%It is well agreed upon that the semantics of such an operation should be a pushout in the category of theory presentations\ednote{cite the other systems or refer to a previous section}.
$\pi_{\Delta}$ and $\pi_{\Phi}$ are two rename functions given to resolve name conflicts. 

\noindent A well-formed combine needs to ensure that any two symbols \lstmath{x $\;\in\;\mid\Delta\mid$} and \lstmath{y $\;\in\;\mid\Phi\mid$} --- after applying the renaming functions --- map to the same symbol if they have originated from the source theory $\Gamma$ and that there are no name clashes when mapping a symbol $z$ across the two morphisms and rename functions.  The precondition for combine operation is described by the following equivalence: 
\begin{equation}
\pi_{\Delta} \left( x \right) = \pi_{\Phi} \left( y \right)
\Leftrightarrow \exists z \in \left| \Gamma \right|.\ x =
\substitution{z}{u_{\Delta}}{} \wedge y = \substitution{z}{u_{\Phi}}{} 
\label{eq:combinePrecond}
\end{equation}

\paragraph{Example}
We have given two examples in the beginning of this section illustrating situations in which combine operations is needed. A \lstmath{PointedMagma} is defined as 
\begin{togcode} 
PointedMagma = combine Magma {} Pointed {} 
\end{togcode} 
The embeddings being combined are \lstmath{Carrier $\;\hookrightarrow\;$ Magma} and \lstmath{Carrier $\;\hookrightarrow\;$ Pointed}. The empty 
\lstinline|{}| means the identity rename functions are used in this expression, as in this case no name clashes need to be resolved. 

The \lstmath{AddSemigroup} is defined as 
\begin{togcode} 
AdditiveSemigroup = combine AdditiveMagma {} Semigroup {op to +} 
\end{togcode} 
The embeddings used here are \lstmath{Magma $\;\mapsto\;$ AdditiveMagma} and \lstmath{Magma $\;\hookrightarrow\;$ Semigroup}. The declaration \lstmath{op} in \lstmath{Magma} is mapped to \lstmath{+} in \lstmath{AdditiveMagma} and remains as \lstmath{op} in \lstmath{Semigroup}. Therefore, a rename \lstinline|{op to +}| is needed to resolve this name clash. 
%The work in \cite{carette2018building} defines $4$ combinators used to build a graph of axiomatic theories in a dependently-typed logic. This graph corresponds to a diagram in the category $\tpcat$ of theory presentations and morphisms between them.
%    \item The category of contexts $\ctxcat$ is the opposite of the category of theory presentations $\tpcatOp$, i.e. if a theory \lstmath{T'} is the extension of a theory \lstmath{T} in the category $\tpcat$, then there is a morphism in $\ctxcat$ from \lstmath{T'} to \lstmath{T} that drops some of the declarations in \lstmath{T}. Because theories are viewed as telescopes, to drop a declaration, all its subsequent ones need to be dropped. 
 %   \item A fibered category is \ednote{short description here}. The category of context $\ctxcat$ forms the basis of a fibration, with the fibered category being the category of extensions $\extcat$. The fibration maps every extension object from $\extcat$ to its source in $\ctxcat$. 

\section{Library Building}
\label{sec:guidelines}
%In Chapter~\ref{sec:lib_implementation} we discuss the implementation of the combinators. 
%Once implementation of combinators is in place, 
Using \lstmath{extends}, \lstmath{rename}, and \lstmath{combine}, we build a library of $227$ theories describing the algebraic hierarchy organized as a theory graph using tiny theories approach. Those theories range from \lstmath{Empty} up to \lstmath{Ring} and  \lstmath{BoundedDistributedLattice}. The library definitions are given in Appendix~\ref{appendix:input}. 
%we start using them to build the library organized as a theory graph. 
Our guide in building this library are the definitions in~\cite{msLibDecls}, which were part of an experiment~\cite{mathscheme2011experiments} on the way to developing the combinators we discuss in this chapter. Therefore, there are some definitions in that library that referred to non-existing morphisms, like the definition of \lstmath{SemiRng} presented in Section~\ref{sec:lib_implementation}. As the implementation of combinators depends on finding the right morphisms in the underlying theory graph, we had to work out the correct morphisms. 
 
The examples in Section~\ref{sec:msCombinators} give an intuition of how the combinators work together to build the library. In this section we discuss some the challenges we faced to build the graph defining \lstmath{AdditiveMonoid} as in Figure~\ref{fig:cube_monoid}.  
%leading to a completely morphism-based development of the library. 

\subsection{Defining AdditivePointedMagma}
The very first theories of the algebraic hierarchy are defined as 
\begin{togcode} 
Carrier = extend Empty {A : Set}
Pointed = extend Carrier {e : A}
Pointed0 = rename Pointed {e to 0} 
Magma = extend Carrier {op : A -> A -> A}
AdditiveMagma = rename Magma {op to +} 
PointedMagma = combine Pointed {} Magma {} over Carrier
\end{togcode} 
These definitions would result in the black theories and morphisms in Figure~\ref{fig:addPointedMagma}. Now we want to defined \lstmath{AdditivePointedMagma} consisting of three declarations \lstmath{(A,+,0)} such that all the blue morphisms of 
Figure~\ref{fig:addPointedMagma} are generated. 
\begin{figure}[h]
    \begin{tikzcd}
   \verb|Empty| \arrow[r,hook] & \verb|Carrier| \arrow[r,hook] \arrow[d,hook] \arrow[rd,hook] & \verb|Magma| \arrow[r,mapsto] \arrow[d,hook] & \verb|AdditiveMagma| \arrow[dd,hook,dashed,blue] \\
  & \verb|Pointed| \arrow[d,mapsto] \arrow[r,hook] & \verb|PointedMagma| \arrow[rd,mapsto,dashed,blue]&    \\
   &  \verb|Pointed0|  \arrow[rr,hook,dashed,blue] & & 
   \textcolor{blue}{\cn{AdditivePointedMagma}} \\       
    \end{tikzcd}
    \caption{The construction of AdditivePointedMagma}
    \label{fig:addPointedMagma}
\end{figure}
Using one \lstmath{combine} to define it, we end up with the one of the following cases. 
\begin{itemize}
 \item  
\begin{togcode}
combine AdditiveMagma {} Pointed0 {} over Carrier
\end{togcode}
would generate the theory \lstmath{AdditivePointedMagma}, and the three morphisms 
\begin{itemize}
    \item \lstmath{Carrier $\;\to\;$ AdditivePointedMagma}, 
    \item \lstmath{AdditiveMagma $\;\to\;$ AdditivePointedMagma}, 
    \item \lstmath{Pointed0 $\;\to\;$ AdditivePointedMagma}. 
\end{itemize}
The morphism \lstmath{PointedMagma $\;\to\;$ AdditivePointedMagma} won't be generated. 

\item  
\begin{togcode}
combine AdditiveMagma {} PointedMagma {op to +} over Magma 
\end{togcode}
will not generate the morphism \lstmath{Pointed0 $\;\to\;$ AdditivePointedMagma}. 

\item 
\begin{togcode}
combine Pointed0 {} PointedMagma {e to 0} over Pointed 
\end{togcode}
will not generate the morphism \lstmath{AdditiveMagma $\;\to\;$ AdditivePointedMagma}. 
\end{itemize}
Instead, to get all these connections, we define \lstmath{AdditivePointedMagma} as follows 
\begin{togcode}
Pointed0Magma = 
  combine Pointed0 {} PointedMagma {e to 0} over Pointed
PointedPlusMagma = 
  combine AdditiveMagma {} PointedMagma {op to +} over Magma
AdditivePointedMagma = 
  combine Pointed0Magma {op to +} PointedPlusMagma {e to 0} 
  over PointedMagma
\end{togcode}
which results in the graph in Figure~\ref{fig:addPointedMagmaReal}.  
\begin{figure}[h]
    \begin{tikzcd}
        \verb|Carrier| \arrow[r,hook] \arrow[d,hook] \arrow[rd,hook] & \verb|Magma| \arrow[r,mapsto] \arrow[d,hook] \arrow[rd,mapsto,dashed,blue] & \verb|AdditiveMagma| \arrow[d,hook,dashed,blue] \\
        \verb|Pointed| \arrow[d,mapsto] \arrow[r,hook] \arrow[rd,mapsto,dashed,blue]& \verb|PointedMagma| \arrow[rd,mapsto,dashed,blue] \arrow[d,mapsto,dashed,blue] \arrow[r,mapsto,dashed,blue] &  \verb|PointedPlusMagma| \arrow[d,hook,dashed,blue] \\
        \verb|Pointed0|  \arrow[r,hook,dashed,blue] & \verb|Pointed0Magma| \arrow[r,hook,dashed,blue] &  \textcolor{blue}{\texttt{AdditivePointedMagma}} \\       
    \end{tikzcd}
    \caption{The construction of AdditivePointedMagma}
    \label{fig:addPointedMagmaReal}
\end{figure}
Although it is not immediately obvious to define \lstmath{AdditivePointedMagma} this way, it corresponds more to the tiny theories approach that advocates having all intermediate theories. The two intermediate theories \lstmath{Pointed0Magma} and \lstmath{PointedPlusMagma} become useful when we define the \lstmath{Zero0} theory, which is defined as follows:  
\begin{togcode}
PointedTimesZeroMagma = 
  combine PointedTimesMagma {e to 0} Pointed0Magma {op to *}
  over PointedMagma 
Zero0 = 
  combine Zero {op to *; e to 0} PointedTimesZeroMagma {} 
  over PointedMagma 
\end{togcode}

\subsection{Defining AdditiveMonoid}
One would want to have \lstmath{AdditiveMonoid} with all the morphisms we introduced in Figure~\ref{fig:cube_monoid}. %But how close we can get to this diagram. 
We have discussed the construction of \lstmath{AdditivePointedMagma} and shown how the construction is not precisely depicted in Figure~\ref{fig:cube_monoid}. Although all the morphisms are defined, some are composed of other morphisms. Now, we focus more on the part of defining \lstmath{AdditiveUnital}. 

\noindent The definition of \lstmath{AdditiveLeftUnital} and \lstmath{AdditiveRightUnital} goes as follows: 
\begin{togcode}
AdditiveLeftUnital = 
  combine AdditivePointedMagma {} LeftUnital {op to +; e to 0} 
  over PointedMagma
AdditiveRightUnital = 
  combine AdditivePointedMagma {} RightUnital {op to +; e to 0} 
  over PointedMagma
\end{togcode} 
\noindent It make sense to expect \lstmath{AdditiveUnital} to have morphisms with all of \lstmath{Unital}, \lstmath{AdditiveLeftUnital}, and \lstmath{AdditiveRightUnital}. Similar to the case we had in the previous section, one pushout will only compute two of these three morphisms. The possible pushouts are 
\begin{togcode}
combine AdditiveLeftUnital {} AdditiveRightUnital {} 
over AdditivePointedMagma
\end{togcode}

\begin{togcode}
combine AdditiveLeftUnital {} Unital {op to +; e to 0} 
over LeftUnital 
\end{togcode}

\begin{togcode}
combine AdditiveRightUnital {} Unital {op to +; e to 0} 
over RightUnital 
\end{togcode}

In order to compute the three, we need to to do $3$ pushouts as follows:
\begin{togcode} 
AUnital1 = combine AdditiveLeftUnital {} Unital {op to +; e to 0} 
           over LeftUnital
AUnital2 = combine AdditiveRightUnital {} Unital {op to +; e to 0} 
           over RightUnital 
AdditiveUnital = combine AUnital1 {} AUnital2 {} over Unital 
\end{togcode} 
The theories \lstmath{AUnital1}, \lstmath{AUnital2}, and \lstmath{AdditiveUnital} are all equivalent. Therefore, the graph would have $3$ presentations of the theory of additive unital without the graph realizing they are equivalent. 
%Unlike the one before, there is no way to compose different pushouts to get the three morphisms. The reason is that all possible pushouts compute the same theory, without the system realizing they are the same. 

The same problem occurs when defining \lstmath{AdditiveMonoid} and attempting to generate the three morphisms 
\begin{itemize}
    \item \lstmath{AdditiveUnital $\;\longrightarrow\;$ AdditiveMonoid}
    \item \lstmath{AdditiveSemigroup $\;\longrightarrow\;$ AdditiveMonoid}
    \item \lstmath{Monoid $\;\longrightarrow\;$ AdditiveMonoid}
\end{itemize}
%AMonoid1 = combine Monoid plus-zero AdditivePointedSemigroup {} over PointedSemigroup
%AMonoid2 = combine Monoid plus-zero AdditiveUnital {} over Unital
%AdditiveMonoid = combine AMonoid1 {} AMonoid2 {} over Monoid  

We considered the possibility of using colimits or diagram combinators as in~\cite{cicm2019diagrams}. In either case, we want to arrive at the right pushouts and build diagrams or colimits on top of that. 
Noticing that in all our experiments, the morphisms we wish to have that are not generated included an identity embedding, we adopted the solution of enabling the user to add those identity embeddings between theories. %This allowed us to substitute for morphisms that are not generated in situations like the one we describe here. 
%Our approach is to define these techniques in terms of pushouts, i.e. provide them as a syntactic sugar to performing multiple pushouts. Since pushouts in the category of contexts are associative, we believed we are able to do that, but the examples above shows that this is not always possible. Therefore, we provided a construction that allows the user to add identity arrows between two theories.\ednote{need to add guarantees that this does not mess with the all-commute-path principle.} 

The declarations that we use to define \lstmath{AdditiveMonoid} are 
\begin{minted}[style=trac]{haskell} 
 Theory Empty = {} 
 Carrier = extend Empty {A : Set}
 Pointed = extend Carrier {e : A}
 Pointed0 = rename Pointed {e to 0} 
 Magma = extend Carrier {op : A -> A -> A}
 AdditiveMagma = rename Magma {op to +} 
 Pointed0Magma = 
   combine Pointed0 {} PointedMagma {e to 0} over Pointed
 PointedPlusMagma = 
   combine AdditiveMagma {} PointedMagma {op to +} over Magma
 AdditivePointedMagma = 
   combine Pointed0Magma {op to +} PointedPlusMagma {e to 0} 
   over PointedMagma
 Semigroup = 
   extend Magma {assoc_op : {x y z : A} -> 
                   op (op x y) z == op x (op y z)}
 AdditiveSemigroup = 
   combine AdditiveMagma {} Semigroup plus over Magma
 LeftUnital = extend PointedMagma {lunit_e : {x : A} -> op e x == x}
 RightUnital = extend PointedMagma {runit_e : {x : A} -> op x e == x}
 AdditiveLeftUnital = 
   combine AdditivePointedMagma {} LeftUnital {op to +; e to 0} 
   over PointedMagma 
 AdditiveRightUnital = 
   combine AdditivePointedMagma {} RightUnital {op to +; e to 0} 
   over PointedMagma 
 Unital = combine LeftUnital {} RightUnital {} over PointedMagma
 AdditiveUnital = 
   combine AdditivePointedMagma {} Unital {op to +; e to 0} 
   over PointedMagma
 idUnital = id from AdditiveRightUnital to AdditiveUnital 
 Monoid = combine Unital {} Semigroup {} over Magma
 AdditiveMonoid = 
   combine AdditiveUnital {} Monoid {op to +; e to 0} over Unital 
 idMonoid = id from AdditiveSemigroup to AdditiveMonoid   
\end{minted} 
\noindent Note that although we give names to identity morphisms, we never needed to refer to them in our development. 

\section{Discussion}
\label{sec:library:discussion}
In many cases, there are many ways to define a theory. We restrict using \lstmath{extension} for adding new concepts within their minimal context, like adding associativity to \lstmath{Magma}. Whenever associativity is needed in a different context, it should be transported through \lstmath{rename} and \lstmath{combine}. In other words, a concept should only be defined once and transported to different theories via morphisms. It is also reasonable to assume that \lstmath{AdditiveMagma} should be an ancestor for any theory that contain the binary {operation \lstmath{+}}. This means that many renames take place using \lstmath{combine} operation, rather than the \lstmath{rename} one. For example, compare the following two definitions of \lstmath{AdditiveSemigroup} 
\begin{togcode}
1. AdditiveSemigroup = rename Semigroup {op to +}
\end{togcode}
\begin{togcode}
2. AdditiveSemigroup = 
       combine AdditiveMagma {} Semigroup {op to +} over Magma 
\end{togcode}
Definition $1$ connects \lstmath{AdditiveSemigroup} only to \lstmath{Semigroup}, but definition $2$ creates more embeddings and connects it to \lstmath{AdditiveMagma}, \lstmath{Semigroup} and \lstmath{Magma}, which enriches the graph with useful morphisms. 

We also find that using theories that are deeper in the hierarchy when possible adds more structure for the graph. For example, here are two possible definitions of \lstmath{CommutativeGroup}:    
\begin{togcode} 
1. CommutativeGroup = 
       combine CommutativeMagma {} Group {} over Magma
\end{togcode} 
\begin{togcode}
2. CommutativeGroup = 
       combine CommutativeMonoid {} Group {} over Monoid
\end{togcode}
The first definition does not connect \lstmath{CommutativeMonoid} and \lstmath{CommutativeGroup}, despite the fact that they are related. The second definition connects them, while also keeping the connection to \lstmath{CommutativeMagma} through the path that exists from it to \lstmath{CommutativeMonoid}. 

These observations stem from the fact that we are not only interested in computing the output theory of the expression, but we are also interested in building a rich theory graph that captures as much of the structure of mathematics as possible. 

In some cases, a whole hierarchy has been developed and one may want to perform a pushout of the whole graph along a morphism, in a similar way to~\cite{cicm2019diagrams} and as shown in Figure~\ref{fig:shiftPMtoRingoid}. We encountered this situation while creating \lstmath{Semiring}, as that is when the additive and multiplicative variants of the theories are combined together. We have not implemented diagram combinators in the Tog framework and leave this as future work. 
%\begin{comment}
\begin{figure}[h]
\adjustbox{scale=0.7}{   
\begin{tikzcd}
& \cn{AddMagma} \arrow[rd, hook] &  & \cn{LeftRingoid} \arrow[rd, hook]  &  \\
\cn{Magma} \arrow[dd, hook] \arrow[ru, maps to] \arrow[rd, maps to] &  & \cn{RingoidSig} \arrow[ru, hook] \arrow[rd, hook] & & \cn{Ringoid} \arrow[dd, dotted, hook] \\
 & \cn{MultMagma} \arrow[ru, hook] & & \cn{RightRingoid} \arrow[ru, hook] & \\
\cn{PointedMagma} \arrow[d, hook] \arrow[rrrr, dotted, hook] & & & & \cn{PointedMagma@Ringoid} \\
\cdots &  &  & &   \\   
 \end{tikzcd} }
\caption{Shift the \cn{PointedMagma} hierarchy to \cn{Ringoid}}
\label{fig:shiftPMtoRingoid}
\end{figure}

Another line of future work is to support general morphisms as described in Section~\ref{sec:generalmorph} and their usage in the \lstmath{mixin} combinator as described in~\cite{carette2018building}. 
The \lstmath{mixin} combinator computes a pushout of an embedding along a general morphism. Given a general morphism \lstmath{$[\text{u}_\Delta]: \Gamma \to \Delta$} and an embedding \lstmath{$[\text{u}_\Phi] : \Gamma \to \Phi$} and two injective renaming functions 
\lstmath{$\pi_\Delta :\ \mid\Delta\mid\ \to \mathbb{S}$}
and \lstmath{$\pi_\Phi :\ \mid\Phi\mid\ \to \mathbb{S}$}, the mixin is defined as follows 
\[
\mixfun\left( u_{\Delta}, u_{\Phi}, \pi_{\Delta}, \pi_{\Phi}\right) \define
\left\{\begin{aligned}
  \mathtt{pres} & = \combineResult_1\rtimes\combineResult_2 \\
  \mathtt{embed}_{\Delta} & = \left[v_{\Delta}\right] : \Delta\rightarrow\combineResult\\
  \mathtt{view}_{\Phi} & = \left[v_{\Phi}\right] : \Phi\rightarrow\combineResult\\
  \mathtt{diag} & = \left[uv\right]:\Gamma\rightarrow\combineResult\\
\end{aligned}\right\}
\]
%  \mathtt{mediate} & = \lambda\ w_{\Delta}\ w_{\Phi}\ .\  w_{\combineResult}
where $\Xi_1 = \pi_\Delta \cdot \Delta$ is the theory presentation resulting from applying the rename function $\pi_\Delta$ to $\Delta$ via substitution. 
$\Xi_2 = \pi_\Phi \cdot \Phi^+$ is not a well-formed theory presentation, instead, it is the result of applying $\pi_\Phi$ to declarations of $\Phi$ that are not mappings of declarations in $\Gamma$. 
In~\cite{carette2018building}, a proof that the mixin operation as described above is always defined has been presented. 

For example, the morphism \lstmath{flip : Magma $\;\to\;$ FlippedMagma} shown in Section~\ref{sec:generalmorph} can be used to construct flipped \lstmath{Semigroup} as follows. 
\begin{togcode} 
FlippedSemigroup = mixin flip {} Semigroup {} 
\end{togcode} 
In this case, $\text{u}_\Delta$ is the \lstmath{flip} morphism, $\text{u}_\Phi$ is the morphism \lstmath{Magma $\;\to\;$ Semigroup}. Therefore, the resulting presentation \lstmath{pres} will have definitions from \lstmath{FlippedMagma} and the associativity axiom from \lstmath{Semigroup}. 

%\end{comment}
%  & AddMagma   &  & LeftRingoid  &  \\

% Magma &  & RingoidSig  & & Ringoid  \\
 
% PointedMagma  & MultMagma & & RightRingoid & \\
%MultMon & Zero &  & & PointedMagma@Ringoid         \\   
%
\begin{comment}
There are two different ways by which a user or a library builder can define a new theory; either by stating all its components or by reusing existing theories. While an end user might in some cases prefer the first approach for the formalization tasks, a library is more rich in information if it deploys the second approach. For example, defining a \group to be a \monoid with inverse gives us more information than what are its declarations, it also tell us about how it is related to \monoid. Most systems provide users with at least inclusions which enable them to include a verbatim version of one theory into the other, so the relation between \group and \monoid mentioned here can be captured. But, is this enough? 

%Combinators are mainly used to create connections between the new theory and existing ones. The have been around since, at least the work of Goguen and Brustall on CLEAR under the name \emph{theory building operations} \cite{Goguen1980}. Their work on theories and morphisms can be seen as an early envision of a theory graph. CLEAR has introduced two combinators to add new declarations to a theory, \lstmath|extend-signature-morphism| adds new symbols to the language of the theory and \lstmath|enrich| which adds new symbols or equations \ednote{corresponding to conservative and non-conservative extension.}The operation \lstmath|combine(T,T')| corresponds to the coproduct of the two theories. Notice how the input to the operation is two theories, not morphisms. The application of an argument to a parameterized theory is computed using the \lstmath{apply(F,$\langle$ F$_1$$\cdots$F$_n$ $\rangle$)}. This operation is arrow-based, but we were not able to find its implementation. It also has a combinator \lstmath{derive(T,$\sigma$,T')} that calculates the quotient of \lstmath{T} by \lstmath{$\sigma$}\ednote{I don't understand this one}.  
\end{comment}