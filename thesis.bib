
% ------ Tog ---------- 
@misc{tog,
  key = {Tog, a dependently-typed checker},
  title = {Tog, A prototypical implementation of dependent types},
  author = {Francesco Mazzoli and Nils Anders Danielsson and Ulf Norell  and Andrea Vezzosi and Andreas Abel},
  year = {2017}, 
  howpublished = {GitHub Repository \url{https://github.com/bitonic/tog}}
}

@misc{mazzoli2016type,
    title={{Type Checking through Unification}},
    author={Mazzoli, Francesco and Abel, Andreas},
    howPublished={arXiv:1609.09709},
    year={2016}
}

% https://github.com/bitonic/tog

% ----- Libraries ------- 

% Coq 
@article{Geuvers2002,
  title = {{A Constructive Algebraic Hierarchy in Coq}},
  journal = {Journal of Symbolic Computation} ,
  volume = {34},
  number = {4},
  pages = {271 - 286},
  year = {2002},
  issn = {0747-7171},
  doi = {https://doi.org/10.1006/jsco.2002.0552},
  url = {http://www.sciencedirect.com/science/article/pii/S0747717102905523},
  author = {Herman Geuvers and Randy Pollack and Freek Wiedijk and Jan Zwanenburg},
  abstract = {We describe a framework of algebraic structures in the proof assistant Coq. We have 
  developed this framework as part of the FTA project in Nijmegen, in which a constructive proof of the 
  fundamental theorem of algebra has been formalized in Coq. The algebraic hierarchy that is described 
  here is both abstract and structured. Structures like groups and rings are part of it in an abstract way, 
  defining e.g. a ring as a tuple consisting of a group, a binary operation and a constant that together 
  satisfy the properties of a ring. In this way, a ring automatically inherits the group properties of the 
  additive subgroup. The algebraic hierarchy is formalized in Coq by applying a combination of labelled 
  record types and coercions. In the labelled record types of Coq, one can use dependent types: the type 
  of one label may depend on another label. This allows us to give a type to a dependent-typed tuple like 
  〈A, f, a〉, where A is a set,f an operation on A and a an element of A. Coercions are functions that are 
  used implicitly (they are inferred by the type checker) and allow, for example, to use the structure A:= 
  〈A, f, a〉 as a synonym for the carrier set A, as is often done in mathematical practice. Apart from the 
  inheritance and reuse of properties, the algebraic hierarchy has proven very useful for reusing notations.}
}

@InProceedings{Gonthier2009,
  author="Garillot, Fran{\c{c}}ois
  and Gonthier, Georges
  and Mahboubi, Assia
  and Rideau, Laurence",
  title={{Packaging Mathematical Structures}},
  booktitle="Theorem Proving in Higher Order Logics",
  year="2009",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="327 -- 342",
  isbn="978-3-642-03359-9"
}

@InProceedings{Spitters2010,
  author="Spitters, Bas
  and van der Weegen, Eelis",
  title={{Developing the Algebraic Hierarchy with Type Classes in Coq}},
  booktitle="Interactive Theorem Proving",
  year="2010",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="490 -- 493",
  abstract="We present a new formalization of the algebraic hierarchy in Coq, exploiting its new type class 
  mechanism to make practical a solution formerly thought infeasible. Our approach addresses both 
  traditional challenges as well as new ones resulting from our ambition to build upon this development a 
  library of constructive analysis in which abstraction penalties inhibiting efficient computation are reduced 
  to a bare minimum. To support mathematically sound abstract interfaces for ℕ, ℤ, and ℚ, our 
  formalization includes portions of category theory and multisorted universal algebra.",
  isbn="978-3-642-14052-5"
}

@misc{coq-contribs-algebra,
   key = {{Coq User Contributions - Algebra Library}},
   title = {{Coq User Contributions - Algebra Library}},
   author = {Loïc Pottier}, 
   howpublished = {GitHub Repository \url{https://github.com/coq-contribs/algebra} v8.10.0}, 
   year = {2019}
}

@InProceedings{spivak2014coqcats,
    author="Gross, Jason, and Chlipala, Adam, and Spivak, David I.",
    title="Experience Implementing a Performant Category-Theory Library in {Coq}",
    booktitle="Interactive Theorem Proving",
    year="2014",
    publisher="Springer International Publishing",
    address="Cham",
    pages="275 -- 291",
    abstract="We describe our experience implementing a broad 
    category-theory library in Coq. Category theory and 
    computational 
    performance are not usually mentioned in the same breath, but 
    we have 
    needed substantial engineering effort to teach Coq to cope with 
    large 
    categorical constructions without slowing proof script 
    processing 
    unacceptably. In this paper, we share the lessons we have 
    learned about 
    how to represent very abstract mathematical objects and 
    arguments in 
    Coq and how future proof assistants might be designed to 
    better support 
    such reasoning. One particular encoding trick to which we draw 
    attention 
    allows category-theoretic arguments involving duality to be 
    internalized 
    in Coq's logic with definitional equality. Ours may be the 
    largest Coq 
    development to date that uses the relatively new Coq version 
    developed 
    by homotopy type theorists, and we reflect on which new 
    features were 
    especially helpful.",
    isbn="978-3-319-08970-6"
}


% Isabelle 
@misc{Isabelle-hol-algebra, 
  key = {Isabelle's HOl-Algebra Library}, 
  title = {Isabelle's HOl-Algebra Library}, 
  howpublished = {\url{https://isabelle.in.tum.de/library/HOL/HOL-Algebra/index.html}}, 
  accessed = {March 10,2020} 
}

% Agda 
@misc{agda_stdlib,
  key={{A}gda Library},
  title={{A}gda {S}tandard {L}ibrary},
  journal={GitHub repository},
  version={1.4},
  year={2020},
  note={Version 1.4},
  howpublished={\url{https://github.com/agda/agda-stdlib}}
}

% Lean: Mathlib 
@article{lean2019,
  title={{The Lean Mathematical Library}},
  author="The Mathlib Team",
  journal = {arXiv: 1910.09336},
  year={2019},
  note={\url{https://arxiv.org/abs/1910.09336}}
}

%CASL reference manual 
@book{CoFI:2004:CASL-RM,
    title={{CASL Reference Manual: The Complete Documentation of the Common Algebraic Specification Language}},
    author={Mosses, Peter D},
    series={Lecture Notes in Computer Science},     
    volume={2960},
    year={2004},
    publisher={Springer, Berlin, Heidelberg}
}

@book{bidoit2003casl,
    title={CASL User Manual: Introduction to Using the Common Algebraic Specification Language},
    author={Bidoit, Michel and Mosses, Peter D},
    volume={2900},
    year={2003},
    publisher={Springer}
}

@article{mathscheme2011experiments,
  author = {Jacques Carette and William M. Farmer and Filip Jeremic and 
  Vincent Maccio and Russell O'Connor and Quang Tran},
  year = {2011},
  month = {June},
  title = {{The MathScheme Library: Some Preliminary Experiments}}, 
  journal={arXiv:1106.1862}
}

@Inbook{Grabowski2020,
    author="Grabowski, Adam
        and Korni{\l}owicz, Artur
        and Schwarzweller, Christoph",
    editor="Grabowski, Adam
        and Loukanova, Roussanka
        and Schwarzweller, Christoph",
    title="Refining Algebraic Hierarchy in Mathematical Repository of Mizar",
    bookTitle="AI Aspects in Reasoning, Languages, and Computation",
    year="2020",
    publisher="Springer International Publishing",
    address="Cham",
    pages="49--75",
    abstract="Mathematics, especially algebra, uses plenty of structures: groups, rings, integral domains, fields, vector spaces to name a few of the most basic ones. Classes of structures are closely connected---usually by inclusion---naturally leading to hierarchies that has been reproduced in different forms in different mathematical repositories. We give a brief overview of some existing algebraic hierarchies and report on the latest developments in the Mizar computerized proof assistant system. In particular we present a detailed algebraic hierarchy that has been defined in Mizar and discuss extensions of the hierarchy towards more involved domains, using internal mechanisms available in the system.",
    isbn="978-3-030-41425-2",
    doi="10.1007/978-3-030-41425-2_2",
    url="https://doi.org/10.1007/978-3-030-41425-2_2"
}



%----------------- Bundling Problem ------------ 
@InProceedings{Gross2014,
  author="Gross, Jason
  and Chlipala, Adam
  and Spivak, David I.",
  editor="Klein, Gerwin
  and Gamboa, Ruben",
  title="Experience Implementing a Performant Category-Theory Library in {Coq}",
  booktitle="Interactive Theorem Proving",
  year="2014",
  publisher="Springer International Publishing",
  address="Cham",
  section = "2",
  pages="275 -- 291",
  abstract="We describe our experience implementing a broad category-theory library in Coq. Category 
  theory and computational performance are not usually mentioned in the same breath, but we have 
  needed substantial engineering effort to teach Coq to cope with large categorical constructions without 
  slowing proof script processing unacceptably. In this paper, we share the lessons we have learned about 
  how to represent very abstract mathematical objects and arguments in Coq and how future proof 
  assistants might be designed to better support such reasoning. One particular encoding trick to which 
  we draw attention allows category-theoretic arguments involving duality to be internalized in Coq's logic 
  with definitional equality. Ours may be the largest Coq development to date that uses the relatively new 
  Coq version developed by homotopy type theorists, and we reflect on which new features were 
  especially helpful.",
  isbn="978-3-319-08970-6"
}

@InProceedings{cohen2020hierarchy,
  author =	{Cyril Cohen and Kazuhiko Sakaguchi and Enrico Tassi},
  title =	{{Hierarchy Builder: Algebraic hierarchies Made Easy in Coq with Elpi (System Description)}},
  booktitle =	{5th International Conference on Formal Structures for Computation and Deduction (FSCD 2020)},
  pages =	{34:1--34:21},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-155-9},
  ISSN =	{1868-8969},
  year =	{2020},
  volume =	{167},
  editor =	{Zena M. Ariola},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/opus/volltexte/2020/12356},
  URN =		{urn:nbn:de:0030-drops-123562},
  doi =		{10.4230/LIPIcs.FSCD.2020.34},
  annote =	{Keywords: Algebraic Hierarchy, Packed Classes, Coq, Elpi, Metaprogramming, λProlog}
}



@misc{mahboubi2017mathematical,
  title={Mathematical components},
  author={Mahboubi, Assia and Tassi, Enrico},
  year={2017}
}

@incollection{CaretteOConnorTPC,
  year={2012},
  isbn={978-3-642-31373-8},
  booktitle={Intelligent Computer Mathematics},
  volume={7362},
  series={Lecture Notes in Computer Science},
  doi={10.1007/978-3-642-31374-5_14},
  title={{Theory Presentation Combinators}},
  url={http://dx.doi.org/10.1007/978-3-642-31374-5_14},
  publisher={Springer Berlin Heidelberg},
  author={Carette, Jacques and O{'}Connor, Russell},
  pages={202-215}
}

@misc{carette2018building,
  title={{Building on the Diamonds between Theories: Theory Presentation Combinators}}, 
  author={Jacques Carette and Russell O'Connor and Yasmine Sharoda},
  year={2019},
  howPublished={arXiv:1812.08079},
  note={Submitted to Journal of Automated Reasoning}
}

@inproceedings{alhassy2019,
  author = {Al-hassy, Musa and Carette, Jacques and Kahl, Wolfram},
  title = {{A Language Feature to Unbundle Data at Will (Short Paper)}},
  booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: 
  Concepts and Experiences},
  series = {GPCE 2019},
  year = {2019},
  isbn = {978-1-4503-6980-0},
  location = {Athens, Greece},
  pages = {14 -- 19},
  numpages = {6},
  url = {http://doi.acm.org/10.1145/3357765.3359523},
  doi = {10.1145/3357765.3359523},
  acmid = {3359523},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {Agda, Emacs, dependent-types, extensible, meta-program, modules, packages},
} 

% Universal Algebra 
@book{whitehead1898treatise,
  title={{A Treatise on Universal Algebra: with Applications}},
  author={Whitehead, A.N.},
  lsbn={12040192},
  series={Cornell University Library historical math monographs},
  url={http://books.google.ca/books?id=XUwNAAAAYAAJ},
  year={1898},
  publisher={The University Press}
}

@article{sankappanavar1981course,
  title={A course in universal algebra},
  author={Sankappanavar, Hanamantagouda P and Burris, Stanley},
  journal={Graduate Texts Math},
  volume={78},
  year={1981}
}

@book{denecke2002universal,
  title={Universal Algebra and Applications in Theoretical Computer Science},
  author={Denecke, K. and Wismath, S.L.},
  isbn={9781584882541},
  lccn={2001054803},
  url={https://books.google.ca/books?id=sCOInFMLOVYC},
  year={2002},
  publisher={Taylor \& Francis}
}

@incollection{sannella2012foundations,
    title = {Category Theory},   
  bookTitle={Foundations of Algebraic Specification and Formal Software Development},
  author={Sannella, D. and Tarlecki, A.},
   pages = {97 -- 153},      
  isbn={9783642173363},
  lccn={2011941495},
  series={Monographs in Theoretical Computer Science. An EATCS Series},
  url={https://books.google.ca/books?id=85CLRvu5QxUC},
  year={2012},
  publisher={Springer Berlin Heidelberg}
}

@book{ehrig1985fundamentals,
  title={Fundamentals of Algebraic Specification 1: Equations and Initial Semantics},
  author={Ehrig, H. and Mahr, B.},
  isbn={9783642699627},
  series={Monographs in Theoretical Computer Science. An EATCS Series},
  url={https://books.google.ca/books?id=YNypCAAAQBAJ},
  year={1985},
  publisher={Springer Berlin Heidelberg}
}

@incollection{handbook1993Maibaum,
    author={Karl Meinke and John V Tucker},
    title={{Universal Algebra}},
    year={1993},
    editor={Samson Abramsky and Dov M. Gabbay and Thomas S. E. Maibaum},
    bookTitle={Handbook of Logic in Computer Science (Vol. 1): Background: Mathematical Structures},
    isbn={0198537352},
    publisher={Oxford University Press, Inc.},
    address={USA}, 
    pages={189–368},
    numpages={180}
}

@incollection{handbook1993CategoricalLogic,
    author={Andrew M. Pitts},
    title = {{Categorical Logic}}, 
    year = {2001},
    editor={Samson Abramsky and Dov M. Gabbay and Thomas S. E. Maibaum},
    bookTitle = {Handbook of Logic in Computer Science (Vol. 5): Logic and algebraic methods},
    isbn = {0198537611},
    publisher = {Oxford University Press, Inc.},
    address = {USA}, 
    pages = {39–123},
    numpages = {85}
}

@incollection{Gries1993EquationalLogic,
author="Gries, David
and Schneider, Fred B.",
title={{Propositional Calculus}},
booktitle={{A Logical Approach to Discrete Math}},
year="1993",
publisher="Springer New York",
address="New York, NY",
pages="41--61",
isbn="978-1-4757-3837-7",
doi="10.1007/978-1-4757-3837-7_8",
url="https://doi.org/10.1007/978-1-4757-3837-7_8"
}

@incollection{Gries1993FormalLogic,
author="Gries, David
and Schneider, Fred B.",
title={{Formal Logic}},
bookTitle={{A Logical Approach to Discrete Math}},
year="1993",
publisher="Springer New York",
address="New York, NY",
pages="125--137",
abstract="We study the general notion of a formal logical system and its interpretations. Thus, we discuss both syntax (proof theory) and semantics (model theory) for logics. We also study constructive logic in a propositional setting.",
isbn="978-1-4757-3837-7",
doi="10.1007/978-1-4757-3837-7_8",
url="https://doi.org/10.1007/978-1-4757-3837-7_8"
}

@article{meinke1992higherTypes,
  title = {{Universal Algebra in Higher Types}},
  journal = "Theoretical Computer Science",
  volume = "100",
  number = "2",
  pages = "385 - 417",
  year = "1992",
  issn = "0304-3975",
  doi = "https://doi.org/10.1016/0304-3975(92)90310-C",
  url = 
  "http://www.sciencedirect.com/science/article/pii/030439759290310C",
  author = "Karl Meinke",
  abstract = "We develop the elementary theory of higher-order 
  universal 
  algebra using the nonstandard approach to finite type theory 
  introduced 
  by Henkin. Basic results include: existence theorems for free 
  and initial 
  higher type algebras, a complete higher type equational 
  calculus, and 
  characterisation theorems for higher type equational and Horn 
  classes."
}

% Theorem Provers 
@InProceedings{Goguen1980,
  author="Burstall, R. M.
  and Goguen, J. A.",
  editor="Bj{\o}orner, Dines",
  title={{The Semantics of Clear, a Specification Language}},
  booktitle="Abstract Software Specifications",
  year="1980",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="292 -- 332",
  abstract="This paper gives a semantics for the Clear language for specifying problems and programs, described by Burstall and Goguen in 1977. A blend of denotational semantics with categorical ideas is used.",
  isbn="978-3-540-38136-5"
}

@Inbook{Obj2000Goguen,
    author={Goguen, Joseph A. and Winkler, Timothy
    and Meseguer, Jos{\'e}
    and Futatsugi, Kokichi
    and Jouannaud, Jean-Pierre},
    title={Introducing OBJ},
    bookTitle={Software Engineering with OBJ: Algebraic Specification in Action},
    year={2000},
    publisher="Springer US",
    address="Boston, MA",
    pages="3--167",
}

@article{farmer1993imps,
    title={{IMPS: An Interactive Mathematical Proof System}},
    author={Farmer, William M and Guttman, Joshua D and Thayer, F Javier},
    journal={Journal of Automated Reasoning},
    volume={11},
    number={2},
    pages={213--248},
    year={1993},
    publisher={Springer}
}

@InProceedings{InterpIMPS1994,
    author="Farmer, William M.",
    editor="Heering, Jan
    and Meinke, Karl
    and M{\"o}ller, Bernhard
    and Nipkow, Tobias",
    title={{Theory Interpretation in Simple Type Theory}},
    booktitle="Higher-Order Algebra, Logic, and Term Rewriting",
    year="1994",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="96--123",
    abstract="Theory interpretation is a logical technique for relating one axiomatic theory to another with important applications in mathematics and computer science as well as in logic itself. This paper presents a method for theory interpretation in a version of simple type theory, called lutins, which admits partial functions and subtypes. The method is patterned on the standard approach to theory interpretation in first-order logic. Although the method is based on a nonclassical version of simple type theory, it is intended as a guide for theory interpretation in classical simple type theories as well as in predicate logics with partial functions.",
    isbn="978-3-540-48579-7"
}


% CASL development graph 
@InProceedings{developmentGraph2000,
    author="Serge Autexier and Dieter Hutter and Heiko Mantel and Axel Schairer",
    editor="Didier Bert and Christine Choppy and Peter D. Mosses",
    title={{Towards an Evolutionary Formal Software-Development Using CASL}},
    booktitle={Recent Trends in Algebraic Development Techniques},
    year="2000",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="73--88",
    abstract="In practice, the formal development of software is an evolutionary process. Failed proof attempts give rise to changes in the specification and such changes invalidate proofs which have been previously performed. Clearly, it is very desirable to preserve much of the proof effort after such changes. In this paper, we propose development graphs as a general framework for modular specifications and define a structure preserving translation of CASL specifications into these graphs. The feature of development graphs, which is most important for an evolutionary process, is that they simplify the analysis of changes to the specification such that their negative effects can be kept to a minimum.",
    isbn="978-3-540-44616-3"
}

% -------- Concepts ------------ 
% -- Telescope 
@article{de1991telescopic,
  title={Telescopic mappings in typed lambda calculus},
  author={de Bruijn, Nicolaas Govert},
  journal={Information and Computation},
  volume={91},
  number={2},
  pages={189 -- 204},
  year={1991},
  publisher={Citeseer}
}

@article{pollack2002dependently,
  title={{Dependently Typed Records in Type Theory}},
  author={Pollack, Robert},
  journal={Formal Aspects of Computing},
  volume={13},
  number={3-5},
  pages={386--402},
  year={2002},
  publisher={Springer}
}


%------------- Universal Algebra Formalizations ----------- 
@InProceedings{capretta99,
  author="Capretta, Venanzio",
  title={{Universal Algebra in Type Theory}},
  booktitle="Theorem Proving in Higher Order Logics",
  year="1999",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="131 -- 148",
  abstract="We present a development of Universal Algebra inside Type Theory, formalized using the proof assistant Coq. We define the notion of a signature and of an algebra over a signature. We use setoids, i.e. types endowed with an arbitrary equivalence relation, as carriers for algebras. In this way it is possible to define the quotient of an algebra by a congruence. Standard constructions over algebras are defined and their basic properties are proved formally. To overcome the problem of defining term algebras in a uniform way, we use types of trees that generalize wellorderings. Our implementation gives tools to define new algebraic structures, to manipulate them and to prove their properties.",
  isbn="978-3-540-48256-7"
}

@article{Gunther2018Agda,
  title = {{Formalization of Universal Algebra in Agda}},
  journal = "Electronic Notes in Theoretical Computer Science",
  volume = "338",
  pages = "147 - 166",
  year = "2018",
  note = "The 12th Workshop on Logical and Semantic Frameworks, with Applications (LSFA 2017)",
  issn = "1571-0661",
  doi = "https://doi.org/10.1016/j.entcs.2018.10.010",
  url = "http://www.sciencedirect.com/science/article/pii/S1571066118300768",
  author = "Emmanuel Gunther and Alejandro Gadea and Miguel Pagano",
  keywords = "universal algebra, formalization of mathematics, equational logic",
  abstract = "In this work we present a novel formalization of universal algebra in Agda. We show that heterogeneous signatures can be elegantly modelled in type-theory using sets indexed by arities to represent operations. We prove elementary results of heterogeneous algebras, including the proof that the term algebra is initial and the proofs of the three isomorphism theorems. We further formalize equational theory and prove soundness and completeness. At the end, we define (derived) signature morphisms, from which we get the contravariant functor between algebras; moreover, we also proved that, under some restrictions, the translation of a theory induces a contra-variant functor between models."
}
=======
% ------------- MKM -------------- 
@article{farmer2004mkm,
  title={{MKM: A New Interdisciplinary Field of Research}},
  author={Farmer, William M},
  journal={ACM SIGSAM Bulletin},
  volume={38},
  number={2},
  pages={47 -- 52},
  year={2004},
  publisher={ACM New York, NY, USA}
}

@inproceedings{kohlhase2010towards,
    title={{Towards MKM in the Large: Modular Representationand Scalable Software Architecture}},
    author={Kohlhase, Michael and Rabe, Florian and Zholudev, Vyacheslav},
    booktitle={International Conference on Intelligent Computer Mathematics},
    pages={370--384},
    year={2010},
    organization={Springer}
}

% --------- Algebraic Hierarchy ------------- 

% the date here is the last updated of the page 
@misc{jipsen,
  author = "Peter Jipsen",
  title = {{List of Mathematical Structures}},
  howpublished = {\url{http://math.chapman.edu/~jipsen/structures/doku.php}},
  year = {2019},
  note = {Accessed: March 20, 2020}
}

%---------- Haskell Deriving ------------------- 
@article{loeh2010genericDeriving,
  author = {Magalh\~{a}es, Jos\'{e} Pedro and Dijkstra, Atze and 
  Jeuring, 
  Johan and L\"{o}h, Andres},
  title = {{A Generic Deriving Mechanism for Haskell}},
  year = {2010},
  issue_date = {November 2010},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {45},
  number = {11},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/2088456.1863529},
  doi = {10.1145/2088456.1863529},
  journal = {ACM SIGPLAN Notices},
  month = sep,
  pages = {37–48},
  numpages = {12},
  keywords = {type classes, datatype-generic programming, 
  haskell}
}

@inproceedings{loeh2018derivingVia,
  author = {Bl\"{o}ndal, Baldur and L\"{o}h, Andres and Scott, 
  Ryan},
  title = {{Deriving Via: Or, How to Turn Hand-Written Instances 
  into an Anti-Pattern}},
  year = {2018},
  isbn = {9781450358354},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3242744.3242746},
  doi = {10.1145/3242744.3242746},
  booktitle = {Proceedings of the 11th ACM SIGPLAN International 
  Symposium on {H}askell},
  pages = {55–67},
  numpages = {13},
  keywords = {functional programming, instances, {H}askell, type 
  classes, 
  deriving},
  location = {St. Louis, MO, USA},
  series = {{H}askell 2018}
}

@misc{haskell,
  key = "{H}askell",
  howpublished = {https://www.haskell.org/},
  title = "{H}askell; An advanced, purely functional programming 
  language",
  note = {Accessed: March 22, 2020}
}

@inproceedings{sheard2002TH, 
    author = {Sheard, Tim and Jones, Simon Peyton}, 
    title = {{Template Meta-Programming for Haskell}}, 
    year = {2002}, 
    isbn = {1581136056}, 
    publisher = {Association for Computing Machinery}, 
    address = {New York, NY, USA}, 
    url = {https://doi.org/10.1145/581690.581691}, 
    doi = {10.1145/581690.581691}, 
    booktitle = {Proceedings of the 2002 ACM SIGPLAN Workshop 
    on 
    {H}askell}, 
    pages = {1–16}, 
    numpages = {16}, 
    keywords = {templates, meta programming}, 
    location = {Pittsburgh, Pennsylvania}, 
    series = {Haskell ’02} }
    
@InProceedings{sheard2001Challenges,
  author={Tim Sheard},
  editor={Walid Taha},
  title={Accomplishments and Research Challenges in Meta-programming},
  booktitle={Semantics, Applications, and Implementation of Program Generation},
  year={2001},
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="2--44",
  abstract="In the last ten years the study of meta-programming systems, as formal systems worthy of study in their own right, has vastly accelerated. In that time a lot has been accomplished, yet much remains to be done. In this invited talk I wish to review recent accomplishments and future research challenges in hopes that this will spur interest in meta-programming in general and lead to new and better meta-programming systems.",
  isbn="978-3-540-44806-8"
}

@article{metaProg2019Survey,
author = {Lilis, Yannis and Savidis, Anthony},
title = {A Survey of Metaprogramming Languages},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0360-0300},
url = {https://doi.org/10.1145/3354584},
doi = {10.1145/3354584},
abstract = {Metaprogramming is the process of writing computer programs that treat programs as data, enabling them to analyze or transform existing programs or generate new ones. While the concept of metaprogramming has existed for several decades, activities focusing on metaprogramming have been increasing rapidly over the past few years, with most languages offering some metaprogramming support and the amount of metacode being developed growing exponentially. In this article, we introduce a taxonomy of metaprogramming languages and present a survey of metaprogramming languages and systems based on the taxonomy. Our classification is based on the metaprogramming model adopted by the language, the phase of the metaprogram evaluation, the metaprogram source location, and the relation between the metalanguage and the object language.},
journal = {ACM Comput. Surv.},
month = oct,
articleno = {113},
numpages = {39},
keywords = {macro systems, Metaprogramming, meta-object protocols, generative programming, aspect-oriented programming, reflection, multistage languages}
}    

@InProceedings{Norell2004TemplateHs,
  author = "Norell, Ulf and Jansson, Patrik",
  editor = "Kozen, Dexter",
  title = "Prototyping Generic Programming in Template {H}askell",
  booktitle = "Mathematics of Program Construction",
  year = "2004",
  publisher = "Springer Berlin Heidelberg",
  address = "Berlin, Heidelberg",
  pages = "314 -- 333",
}

@Misc{lensesLib,
    key = "Lens Library",
    title = {{Haskell Lens Library}},
    howpublished = {\url{https://hackage.haskell.org/package/lens}},
    year = {2020},
    note = {version 4.19.1; Accessed: 2020-03-22}
}

@Misc{syb,
    key={{S}crap {Y}our {B}oilerplate},
    title = {Haskell Scrap-your-boilerplate Package},
    howpublished = {\url{https://hackage.haskell.org/package/syb}},
    year={2019},
    note = {version 0.7.1; Accessed: 2020-11-18}
}

@inproceedings{LittleTheories,
    author = {W. M. Farmer and J. D. Guttman and F. J. Thayer},
    title = {{Little Theories}},
    booktitle = {CADE-11: Proceedings of the 11th International 
    Conference on Automated Deduction},
    year = {1992},
    isbn = {3-540-55602-8},
    pages = {567 -- 581},
    publisher = {Springer-Verlag},
    address = {London, UK},
}

@article{carette2009finally,
    title={{Finally Tagless, Partially Evaluated: Tagless Staged 
    Interpreters for Simpler Typed Languages}},
    author={Carette, Jacques and Kiselyov, Oleg and Shan, Chung-chieh},
    journal={Journal of Functional Programming},
    volume={19},
    number={5},
    pages={509 -- 543},
    year={2009},
    publisher={Cambridge University Press}
}

@inproceedings{carette2011generative,
  title={{A Generative Geometric Kernel}},
  author={Carette, Jacques and Elsheikh, Mustafa and Smith, Spencer},
  booktitle={Proceedings of the 20th ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
  pages={53 -- 62},
  year={2011},
  organization={ACM}
}
@InProceedings{carette2011mspFunctorsMonads,
author="Carette, Jacques
and Kiselyov, Oleg",
editor="Gl{\"u}ck, Robert
and Lowry, Michael",
title={{Multi-stage Programming with Functors and Monads: Eliminating Abstraction Overhead from Generic Code}},
booktitle="Generative Programming and Component Engineering",
year="2005",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="256--274",
abstract="With Gaussian Elimination as a representative family of numerical and symbolic algorithms, we use multi-stage programming, monads and Ocaml's advanced module system to demonstrate the complete elimination of the abstraction overhead while avoiding any inspection of the generated code. We parameterize our Gaussian Elimination code to a great extent (over domain, matrix representations, determinant tracking, pivoting policies, result types, etc) at no run-time cost. Because the resulting code is generated just right and not changed afterwards, we enjoy MetaOCaml's guaranty that the generated code is well-typed. We further demonstrate that various abstraction parameters (aspects) can be made orthogonal and compositional, even in the presence of name-generation for temporaries and other bindings and ``interleaving'' of aspects. We also show how to encode some domain-specific knowledge so that ``clearly wrong'' compositions can be statically rejected by the compiler when processing the generator rather than the generated code.",
isbn="978-3-540-31977-1"
}



----------- Maude -----
@inproceedings{Maude,
    author = "M. Clavel and S. Eker and P. Lincoln and J. Meseguer",
    title = "Principles of {Maude}",
    booktitle = "Proceedings of the First International Workshop on Rewriting Logic",
    volume = "4",
    editor = "J. Meseguer",
    pages = "65--89",
    year = "1996",
}

-------------- Logic --------- 
@book{enderton1972mathematical,
    title={{A Mathematical Introduction to Logic}},
    author={Enderton, Herbert B},
    year={1972},
    publisher={Academic Press}
}

@book{tarski1953undecidable,
    title={Undecidable Theories},
    author={Tarski, Alfred and Mostowski, Andrzej and Robinson, Raphael Mitchel},
    volume={13},
    year={1953},
    publisher={Elsevier}
}

% The diamond problem 

@inproceedings{sakkinen1989disciplined,
    title={{Disciplined Inheritance}},
    author={Sakkinen, Markku},
    booktitle={ECOOP},
    volume={89},
    pages={39--56},
    year={1989}
}

@phdthesis{jigsaw1992,
    author = {Bracha, Gilad},
    title = {The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance}, 
    school = {The University of Utah},
    month={March},
    year = {1992}
}

@article{traits2006,
    author = {Ducasse, St{\'e}phane and Nierstrasz, Oscar and Sch\"{a}rli, Nathanael and Wuyts, Roel and Black, Andrew P.},
    title = {{Traits: A Mechanism for Fine-grained Reuse}},
    journal = {ACM Trans. Program. Lang. Syst.},
    issue_date = {March 2006},
    volume = {28},
    number = {2},
    month = mar,
    year = {2006},
    issn = {0164-0925},
    pages = {331--388},
    numpages = {58},
    url = {http://doi.acm.org/10.1145/1119479.1119483},
    doi = {10.1145/1119479.1119483},
    acmid = {1119483},
    publisher = {ACM},
    address = {New York, NY, USA},
    keywords = {Languages, Smalltalk, inheritance, mixins, multiple inheritance, reuse, traits},
} 

@InProceedings{diamonds2011,
    author="Wimmer, Manuel
    and Kappel, Gerti
    and Kusel, Angelika
    and Retschitzegger, Werner
    and Sch{\"o}nb{\"o}ck, Johannes
    and Schwinger, Wieland
    and Kolovos, Dimitris
    and Paige, Richard
    and Lauder, Marius
    and Sch{\"u}rr, Andy
    and Wagelaar, Dennis",
    editor="Cabot, Jordi
    and Visser, Eelco",
    title={{A Comparison of Rule Inheritance in Model-to-Model Transformation Languages}},
    booktitle="Theory and Practice of Model Transformations",
    year="2011",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="31--46",
    abstract="Although model transformations presumably play a major role in Model-Driven Engineering, reuse mechanisms such as inheritance have received little attention so far. In this paper, we propose a comparison framework for rule inheritance in declarative model-to-model transformation languages, and provide an in-depth evaluation of three prominent representatives thereof, namely ATL, ETL (declarative subsets thereof), and TGGs. The framework provides criteria for comparison along orthogonal dimensions, covering static aspects, which indicate whether a set of inheriting transformation rules is well-formed at compile-time, and dynamic aspects, which describe how inheriting rules behave at run-time. The application of this framework to dedicated transformation languages shows that, while providing similar syntactical inheritance concepts, they exhibit different dynamic inheritance semantics and offer basic support for checking static inheritance semantics, only.",
    isbn="978-3-642-21732-6"
}

% QED ---- 
@article{boyer1994qed,
    title={{The QED manifesto}},
    author={Boyer, Robert and others},
    journal={Automated Deduction--CADE},
    volume={12},
    pages={238--251},
    year={1994}
}

@article{qedrealoaded2016,
    author = {Michael Kohlhase and Florian Rabe},
    title = {{QED Reloaded: Towards a Pluralistic Formal Library of Mathematical Knowledge}},
    journal = {Journal of Formalized Reasoning},
    volume = {9},
    number = {1},
    year = {2016},
    keywords = {QED; library integration; mathematical knoweldge management},
    abstract = {Proposed in 1994, the ``QED project'' was one of the seminally influential initiatives in automated reasoning: It envisioned the formalization of ``all of mathematics'' and the assembly of these formalizations in a single coherent database. Even though it never led to the concrete system, communal resource, or even joint research envisioned in the QED manifesto, the idea lives on and shapes the research agendas of a significant part of the communityThis paper surveys a decade of work on representation languages and knowledge management tools for mathematical knowledge conducted in the KWARC research group at Jacobs University Bremen.It assembles the various research strands into a coherent agenda for realizing the QED dream with modern insights and technologies.},
    issn = {1972-5787},	pages = {201--234},	doi = {10.6092/issn.1972-5787/4570},
    url = {https://jfr.unibo.it/article/view/4570}
}

% The Haskell Hierarchy 
@misc{wiki:haskell_hierarch,
    key = {{Haskell Wiki}},
    title = {{Functor-Applicative-Monad Proposal}},
    year = "2015",
    url = "https://wiki.haskell.org/Functor-Applicative-Monad_Proposal",
    note = "[Online; accessed 14-November-2019]"
}

@article{spitters2011type,
    title={{Type Classes for Mathematics in Type Theory}},
    author={Spitters, Bas and Van der Weegen, Eelis},
    journal={arXiv preprint arXiv:1102.1323},
    year={2011}
}

% Biform Theories 
@InProceedings{biformCICM2018,
    author="Carette, Jacques
    and Farmer, William M.
    and Sharoda, Yasmine",
    editor="Rabe, Florian
    and Farmer, William M.
    and Passmore, Grant O.
    and Youssef, Abdou",
    title={{Biform Theories: Project Description}},
    booktitle="Intelligent Computer Mathematics",
    year="2018",
    publisher="Springer International Publishing",
    address="Cham",
    pages="76--86",
    abstract="A biform theory is a combination of an axiomatic theory and an algorithmic theory that supports the integration of reasoning and computation. These are ideal for specifying and reasoning about algorithms that manipulate mathematical expressions. However, formalizing biform theories is challenging as it requires the means to express statements about the interplay of what these algorithms do and what their actions mean mathematically. This paper describes a project to develop a methodology for expressing, manipulating, managing, and generating mathematical knowledge as a network of biform theories. It is a subproject of MathScheme, a long-term project at McMaster University to produce a framework for integrating formal deduction and symbolic computation.",
    isbn="978-3-319-96812-4"
}

% One Brain Barrier 
@article{carette2020bigMath,
    title={{Big Math and the One-Brain Barrier -- The Tetrapod Model of Mathematical Knowledge}},
    author={Jacques Carette and William M. Farmer and Michael Kohlhase and Florian Rabe},
    journal={Mathematical Intelligencer},
    year={2020}
}

% cicm diagrams 
@InProceedings{cicm2019diagrams,
    author="Rabe, Florian
    and Sharoda, Yasmine",
    editor="Kaliszyk, Cezary
    and Brady, Edwin
    and Kohlhase, Andrea
    and Sacerdoti Coen, Claudio",
    title={{Diagram Combinators in MMT}},
    booktitle="Intelligent Computer Mathematics",
    year="2019",
    publisher="Springer International Publishing",
    address="Cham",
    pages="211--226",
    abstract="Formal libraries, especially large ones, usually employ modularity to build and maintain large theories efficiently. Although the techniques used to achieve modularity vary between systems, most of them can be understood as operations in the category of theories and theory morphisms. This yields a representation of libraries as diagrams in this category, with all theory-forming operations extending the diagram.",
    isbn="978-3-030-23250-4"
}

@techreport{piroi2007organisational,
    title={{Organisational Tools for MKM in Theorema}},
    author={Piroi, Florina and Buchberger, Bruno and Rosenkranz, Camelia and Jebelean, Tudor},
    year={2007},
    institution={Technical report}
}

@misc{theoriesAndDts,
  key = {Theories and Data Structures},
  title = {Theories and Data Structures},
  author = {Al-hassy, Musa and Carette, Jacques and Kahl, Wolfram},
  journal = {GitHub Repository},
  date = {2019}, 
  howpublished = {\url{https://github.com/JacquesCarette/TheoriesAndDataStructures}}
}

@article{automatedReasoning,
    title={How Close Are Computers to Automating Mathematical Reasoning?},
    author={Stephen Ornes},
    journal={Quantamagazine},
    year={2020}
}

@InProceedings{diagrams_mmt,
    author="Rabe, Florian
    and Sharoda, Yasmine",
    editor="Kaliszyk, Cezary
    and Brady, Edwin
    and Kohlhase, Andrea
    and Sacerdoti Coen, Claudio",
    title="Diagram Combinators in MMT",
    booktitle="Intelligent Computer Mathematics",
    year="2019",
    publisher="Springer International Publishing",
    address="Cham",
    pages="211--226",
    abstract="Formal libraries, especially large ones, usually employ modularity
    to build and maintain large theories efficiently. Although the techniques used
    to achieve modularity vary between systems, most of them can be understood as
    operations in the category of theories and theory morphisms. This yields a
    representation of libraries as diagrams in this category, with all
    theory-forming operations extending the diagram.",
    isbn="978-3-030-23250-4"
}

@InProceedings{leverageCICM2020,
    author="Carette, Jacques
    and Farmer, William M.
    and Sharoda, Yasmine",
    editor="Benzm{\"u}ller, Christoph
    and Miller, Bruce",
    title={{Leveraging the Information Contained in Theory Presentations}},
    booktitle="Intelligent Computer Mathematics",
    year="2020",
    publisher="Springer International Publishing",
    address="Cham",
    pages="55--70",
    abstract="A theorem prover without an extensive library is much less useful to its potential users. Algebra, the study of algebraic structures, is a core component of such libraries. Algebraic theories also are themselves structured, the study of which was started as Universal Algebra. Various constructions (homomorphism, term algebras, products, etc.) and their properties are both universal and constructive. Thus they are ripe for being automated. Unfortunately, current practice still requires library builders to write these by hand. We first highlight specific redundancies in libraries of existing systems. Then we describe a framework for generating these derived concepts from theory definitions. We demonstrate the usefulness of this framework on a test library of 227 theories.",
    isbn="978-3-030-53518-6"
}

@misc{bercic2020space,
    title={{The Space of Mathematical Software Systems -- A Survey of Paradigmatic Systems}},
    author={Katja Bercic and Jacques Carette and William M. Farmer and Michael Kohlhase and Dennis Müller and Florian Rabe and Yasmine Sharoda},
    year={2020},
    howPublished ={arXiv:2002.04955}
}

% algebra textbooks 
@book{mckenzie1987algebras,
    title={{Algebras, Lattices, Varieties}},
    author={McKenzie, Ralph N and McNulty, George F and Taylor, Walter F},
    volume={1},
    year={1987},
    publisher={American Mathematical Soc.}
}

@book{jacobson1985basic,
    title={{Basic Algebra I}},
    author={Jacobson, Nathan},
    year={1985},
    publisher={W. H. Freeman and Company}
}

@article{MMT,
    author = {Rabe, Florian and Kohlhase, Michael},
    title = {A Scalable Module System},
    journal = {Inf. Comput.},
    issue_date = {September, 2013},
    volume = {230},
    month = sep,
    year = {2013},
    issn = {0890-5401},
    pages = {1--54},
    numpages = {54},
    url = {http://dx.doi.org/10.1016/j.ic.2013.06.001},
    doi = {10.1016/j.ic.2013.06.001},
    acmid = {2527919},
    publisher = {Academic Press, Inc.},
    address = {Duluth, MN, USA},
} 

% ----- Printer ------ 
@article{wadler2003prettier,
    title={{A Prettier Printer}},
    author={Wadler, Philip},
    journal={The Fun of Programming, Cornerstones of Computing},
    pages={223--243},
    year={2003},
    publisher={Citeseer}
}

% ------ Misc Related Work ------ 
@article{schwarzweller2007mizar,
    title={Mizar attributes: A technique to encode mathematical knowledge into type systems},
    author={Schwarzweller, Christoph},
    journal={Studies in Logic, Grammar and Rhetoric},
    volume={10},
    number={23},
    pages={387--400},
    year={2007},
    publisher={Citeseer}
}


@InProceedings{canonical2013,
    author="Mahboubi, Assia
    and Tassi, Enrico",
    editor="Blazy, Sandrine
    and Paulin-Mohring, Christine
    and Pichardie, David",
    title={{Canonical Structures for the Working Coq User}},
    booktitle="Interactive Theorem Proving",
    year="2013",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="19--34",
    abstract="This paper provides a gentle introduction to the art of programming type inference with the mechanism of Canonical Structures. Programmable type inference has been one of the key ingredients for the successful formalization of the Odd Order Theorem using the Coq proof assistant. The paper concludes comparing the language of Canonical Structures to the one of Type Classes and Unification Hints.",
    isbn="978-3-642-39634-2"
}

@misc{sakaguchi2020validating,
    title={{Validating Mathematical Structures}},
    author={Sakaguchi, Kazuhiko},
    howPublished={arXiv:2002.00620},
    year={2020}
}

@book{mathCompBook2020,
  author={Assia Mahboubi and Enrico Tassi},
  title={Mathematical Components},
  publisher={Zenodo},
  year={2020},
  month={November},
  url={\url{https://math-comp.github.io/mcb/}}
}

@InProceedings{elpi,
    author="Dunchev, Cvetan
    and Guidi, Ferruccio
    and Sacerdoti Coen, Claudio
    and Tassi, Enrico",
    editor="Davis, Martin
    and Fehnker, Ansgar
    and McIver, Annabelle
    and Voronkov, Andrei",
    title={{ELPI: Fast, Embeddable, $\lambda$Prolog Interpreter}},
    booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
    year="2015",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="460--468",
    isbn="978-3-662-48899-7"
}

@inproceedings{elpiForCoq,
    TITLE = {{Elpi: an extension language for Coq (Metaprogramming Coq in the Elpi $\lambda$Prolog dialect)}},
    AUTHOR = {Tassi, Enrico},
    booktitle={Fourth International Workshop on Coq for Programming Languages},
    URL = {https://hal.inria.fr/hal-01637063},
    YEAR = {2018},
    MONTH = Jan,
    KEYWORDS = {Coq ; $\lambda$Prolog ; metaprogramming ; extension language},
    PDF = {https://hal.inria.fr/hal-01637063/file/coqpl2018.pdf},
    HAL_ID = {hal-01637063},
    HAL_VERSION = {v1},
}

@inproceedings{rabe2018structuring,
    title={Structuring theories with implicit morphisms},
    author={Rabe, Florian and M{\"u}ller, Dennis},
    booktitle={International Workshop on Algebraic Development Techniques},
    pages={154--173},
    year={2018},
    organization={Springer}
}

@inproceedings{kammuller1999locales,
    title={Locales a sectioning concept for Isabelle},
    author={Kamm{\"u}ller, Florian and Wenzel, Markus and Paulson, Lawrence C},
    booktitle={International Conference on Theorem Proving in Higher Order Logics},
    pages={149--165},
    year={1999},
    organization={Springer}
}

@inproceedings{ballarin2003locales,
    title={{Locales and Locale Expressions in Isabelle/Isar}},
    author={Clemens Ballarin},
    booktitle={International Workshop on Types for Proofs and Programs},
    pages={34--50},
    year={2003},
    organization={Springer}
}

@inproceedings{ballarin2010tutorial,
    title={{Tutorial to Locales and Locale Interpretation}},
    author={Clemens Ballarin},
    booktitle={Contribuciones cient{\'\i}ficas en honor de Mirian Andr{\'e}s G{\'o}mez},
    pages={123--140},
    year={2010},
    organization={Universidad de La Rioja}
}

@incollection{Smith99,
    author = {Douglas R. Smith},
    title = {{Mechanizing the Development of Software}},
    year = 1999,
    editor = "M. Broy and R. Steinbrueggen",
    booktitle = "Calculational System Design, Proceedings of the NATO 
    Advanced Study Institute",
    publisher = "IOS Press, Amsterdam",
    pages = "251-292"
}

@article{duran2007maude,
    title={{Maude's Module Algebra}},
    author={Dur{\'a}n, Francisco and Meseguer, Jos{\'e}},
    journal={Science of Computer Programming},
    volume={66},
    number={2},
    pages={125--153},
    year={2007},
    publisher={Elsevier}
}

@article{rabe2013scalable,
    title={{A Scalable Module System}},
    author={Rabe, Florian and Kohlhase, Michael},
    journal={Information and Computation},
    volume={230},
    pages={1--54},
    year={2013},
    publisher={Elsevier}
}

@inproceedings{coqDeriveEquality2019,
    TITLE = {{Deriving proved equality tests in Coq-elpi: Stronger induction principles for containers in Coq}},
    AUTHOR = {Tassi, Enrico},
    URL = {https://hal.inria.fr/hal-01897468},
    BOOKTITLE = {{ITP 2019 - 10th International Conference on Interactive Theorem Proving}},
    ADDRESS = {Portland, United States},
    YEAR = {2019},
    MONTH = Sep,
    DOI = {10.4230/LIPIcs.CVIT.2016.23},
    KEYWORDS = {Parametricity translation ; Coq ; Equality test ; Induction ; Containers},
    PDF = {https://hal.inria.fr/hal-01897468v2/file/induction.pdf},
    HAL_ID = {hal-01897468},
    HAL_VERSION = {v2},
}

@misc{coqDeriveSubterm2020,
    title={{Generating induction principles and subterm relations for inductive types using MetaCoq}}, 
    author={Bohdan Liesnikov and Marcel Ullrich and Yannick Forster},
    year={2020},
    howPublished={arXiv:2006.15135},
}

% --- Code Generation ----- 
@InProceedings{IsabelleCodegen2010,
    author="Haftmann, Florian
    and Nipkow, Tobias",
    editor="Blume, Matthias
    and Kobayashi, Naoki
    and Vidal, Germ{\'a}n",
    title={{Code Generation via Higher-Order Rewrite Systems}},
    booktitle="Functional and Logic Programming",
    year="2010",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="103--117",
    abstract="We present the meta-theory behind the code generation facilities of Isabelle/HOL. To bridge the gap between the source (higher-order logic with type classes) and the many possible targets (functional programming languages), we introduce an intermediate language, Mini-Haskell. To relate the source and the intermediate language, both are given a semantics in terms of higher-order rewrite systems (HRSs). In a second step, type classes are removed from Mini-Haskell programs by means of a dictionary translation; we prove the correctness of this step. Building on equational logic also directly supports a simple but powerful algorithm and data refinement concept.",
    isbn="978-3-642-12251-4"
}

@InProceedings{CoqCodegen2003,
    author="Letouzey, Pierre",
    editor="Geuvers, Herman
    and Wiedijk, Freek",
    title={{A New Extraction for Coq}},
    booktitle="Types for Proofs and Programs",
    year="2003",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="200--219",
    abstract="We present here a new extraction mechanism for the Coq proof assistant [17]. By extraction, we mean automatic generation of functional code from Coq proofs, in order to produce certified programs. In former versions of Coq, the extraction mechanism suffered several limitations and in particular worked only with a subset of the language. We first discuss difficulties encountered and solutions proposed to remove these limitations. Then we give a proof of correctness for a theoretical model of the new extraction. Finally we describe the actual implementation distributed in Coq version 7.3 and further.",
    isbn="978-3-540-39185-2"
}

@inproceedings{cruz2003program,
    title={{Program Extraction from Large Proof Developments}},
    author={Cruz-Filipe, Lu{\'\i}s and Spitters, Bas},
    booktitle={International Conference on Theorem Proving in Higher Order Logics},
    pages={205--220},
    year={2003},
    organization={Springer}
}

@article{Muller2017alignment,
    title={{Alignment-based Translations Across Formal Systems Using Interface Theories}},
    volume={262},
    ISSN={2075-2180},
    url={http://dx.doi.org/10.4204/EPTCS.262.7},
    DOI={10.4204/eptcs.262.7},
    journal={Electronic Proceedings in Theoretical Computer Science},
    publisher={Open Publishing Association},
    author={Müller, Dennis and Rothgang, Colin and Liu, Yufei and Rabe, Florian},
    year={2017},
    month={Dec},
    pages={77–93}
}

% Mizar to Isabelle 
@InProceedings{mizarToIsabelle2018,
    author="Kaliszyk, Cezary
    and P{\k{a}}k, Karol",
    editor="Rabe, Florian
    and Farmer, William M.
    and Passmore, Grant O.
    and Youssef, Abdou",
    title={{Isabelle Import Infrastructure for the Mizar Mathematical Library}},
    booktitle="Intelligent Computer Mathematics",
    year="2018",
    publisher="Springer International Publishing",
    address="Cham",
    pages="131--146",
    abstract="We present an infrastructure that allows importing an initial part of the Mizar Mathematical Library into the Isabelle/Mizar object logic. For this, we first combine the syntactic information provided by the Mizar parser with the syntactic one originating from the Mizar verifier. The proof outlines are then imported by an Isabelle package, that translates particular Mizar directives to appropriate Isabelle meta-logic constructions. This includes processing of definitions, notations, typing information, and the actual theorem statements, so far without proofs. To show that the imported 100 articles give rise to a usable Isabelle environment, we use the environment to formalize proofs in the Isabelle/Mizar environment using the imported types and their properties.",
    isbn="978-3-319-96812-4"
}

@InProceedings{kaliszyk2019DeclProofTerms,
    author =	{Cezary Kaliszyk and Karol Pak},
    title =	{{Declarative Proof Translation (Short Paper)}},
    booktitle =	{10th International Conference on Interactive Theorem Proving (ITP 2019)},
    pages =	{35:1--35:7},
    series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
    ISBN =	{978-3-95977-122-1},
    ISSN =	{1868-8969},
    year =	{2019},
    volume =	{141},
    editor =	{John Harrison and John O'Leary and Andrew Tolmach},
    publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
    address =	{Dagstuhl, Germany},
    URL =		{http://drops.dagstuhl.de/opus/volltexte/2019/11090},
    URN =		{urn:nbn:de:0030-drops-110903},
    doi =		{10.4230/LIPIcs.ITP.2019.35},
    annote =	{Keywords: Declarative Proof, Translation, Isabelle/Isar, Mizar}
}

@InProceedings{impsToOmdoc2018,
    author={Jonas Betzendahl and Michael Kohlhase},
    editor={Florian Rabe and William M. Farmer and Grant O. Passmore and Abdou Youssef},
    title={{Translating the IMPS Theory Library to MMT/OMDoc}},
    booktitle={Intelligent Computer Mathematics},
    year="2018",
    publisher="Springer International Publishing",
    address="Cham",
    pages="7--22",
    abstract="The IMPS system by Farmer, Guttman and Thayer was an influential automated reasoning system, pioneering mechanisations of features like theory morphisms, partial functions with subsorts, and the little theories approach to the axiomatic method. It comes with a large library of formalised mathematical knowledge covering a broad spectrum of different fields. Since IMPS is no longer under development, this library is in danger of being lost. In its present form, it is also not compatible for use with any other mathematical system.",
    isbn="978-3-319-96812-4"
}

@article{iancu2013mizar,
    title={{The Mizar Mathematical Library in OMDoc: Translation and Applications}},
    author={Iancu, Mihnea and Kohlhase, Michael and Rabe, Florian and Urban, Josef},
    journal={Journal of Automated Reasoning},
    volume={50},
    number={2},
    pages={191--202},
    year={2013},
    publisher={Springer}
}

@article{Lewis_2017,
    title={{An Extensible Ad Hoc Interface between Lean and Mathematica}},
    volume={262},
    ISSN={2075-2180},
    url={http://dx.doi.org/10.4204/EPTCS.262.4},
    DOI={10.4204/eptcs.262.4},
    journal={Electronic Proceedings in Theoretical Computer Science},
    publisher={Open Publishing Association},
    author={Lewis, Robert Y.},
    year={2017},
    month={Dec},
    pages={23–37}
}

@techreport{localeIntepretations2006,
    author = {Clemens Ballarin}, 
    title = {{Interpretation of Locales in Isabelle: Managing Dependencies between Locales}},
    year = {2006},
    institution = {Technische Universität München (TUM)},
    keywords = {Interactive proof;theory interpretation;Isabelle},
}

@book{czarnecki2000generative,
    title={Generative Programming: Methods, Tools, and Applications},
    author={Czarnecki, K. and Eisenecker, U.},
    isbn={9780201309775},
    lccn={00028389},
    url={https://books.google.ca/books?id=4CPmr3qcVvYC},
    year={2000},
    publisher={Addison Wesley}
}

@article{stagedConfig,
    author = {Czarnecki, Krzysztof and Helsen, Simon and Eisenecker, Ulrich},
    title = {{Staged Configuration through Specialization and Multilevel Configuration of Feature Models}},
    journal = {Software Process: Improvement and Practice},
    volume = {10},
    number = {2},
    pages = {143-169},
    keywords = {software product lines, system families, domain analysis, software configuration},
    doi = {10.1002/spip.225},
    url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spip.225},
    eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spip.225},
    abstract = {Abstract Feature modeling is a key technique for capturing commonalities and variabilities in system families and product lines. In this article, we propose a cardinality-based notation for feature modeling, which integrates a number of existing extensions of previous approaches. We then introduce and motivate the novel concept of staged configuration. Staged configuration can be achieved by the stepwise specialization of feature models or by multilevel configuration, where the configuration choices available in each stage are defined by separate feature models. Staged configuration is important because, in a realistic development process, different groups and different people make product configuration choices in different stages. Finally, we also discuss how multilevel configuration avoids a breakdown between the different abstraction levels of individual features. This problem, sometimes referred to as 'analysis paralysis', easily occurs in feature modeling because features can denote entities at arbitrary levels of abstraction within a system family. Copyright © 2005 John Wiley \& Sons, Ltd.},
    year = {2005}
}

% Reddit post 
@misc{redditGenHom,
  title = {Is there a way to define a type of homomorphisms?},
  howpublished = {Reddit post},
  month = {September},
  year = {2016},
  note = {Accessed: November 3, 2020}
}



@misc{agdaGenPull, 
  title = {Add some standard algebraic constructs (unit and pairing)},
  howPublished = {Github pull request 1109: https://github.com/agda/agda-stdlib/pull/1109},
  month = {March}, 
  year = {2020}, 
  note = {Accessed: November 3, 2020}
}

@article{oneThingSame2008,
  title={{When is One Thing Equal to Some Other Thing?}},
  author={Mazur, Barry},
  journal={Proof and other dilemmas: Mathematics and philosophy},
  volume={59},
  pages={221},
  year={2008},
  publisher={MAA}
}

@INPROCEEDINGS{equalityInTPs2015,  
  author={A. {Grabowski} and A. {Korniłowicz} and C. {Schwarzweller}},  
  booktitle={2015 Federated Conference on Computer Science and Information Systems (FedCSIS)},   
  title={{Equality in Computer Proof-Assistants}},   
  year={2015},   
  pages={45-54},  
  doi={10.15439/2015F229}}
  
@phdthesis{taha1999multi,
  title={{Multi-Stage Programming: Its Theory and Applications}},
  author={Taha, Walid},
  year={1999},
  school={Oregon Graduate Institute of Science and Technology}
}  

@inproceedings{yallop2016StagingGeneric,
author = {Yallop, Jeremy},
title = {{Staging Generic Programming}},
year = {2016},
isbn = {9781450340977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2847538.2847546},
doi = {10.1145/2847538.2847546},
abstract = { Generic programming libraries such as Scrap Your Boilerplate eliminate the need to write repetitive code, but typically introduce significant performance overheads. This leaves programmers with the unfortunate choice of writing succinct but slow programs or writing tedious but efficient programs. We show how to systematically transform an implementation of the Scrap Your Boilerplate library in the multi-stage programming language MetaOCaml to eliminate the overhead, making it possible to combine the benefits of high-level abstract programming with the efficiency of low-level code. },
booktitle = {Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
pages = {85–96},
numpages = {12},
keywords = {MetaOCaml, generic programming, multi-stage programming, partial evaluation, ML},
location = {St. Petersburg, FL, USA},
series = {PEPM '16}
}

@article{sheard2000stagingDSL,
author = {Sheard, Tim and Benaissa, Zine-el-abidine and Pasalic, Emir},
title = {{DSL Implementation Using Staging and Monads}},
year = {2000},
issue_date = {Jan. 2000},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/331963.331975},
doi = {10.1145/331963.331975},
abstract = {The impact of Domain Specific Languages (DSLs) on software design is considerable. They allow programs to be more concise than equivalent programs written in a high-level programming languages. They relieve programmers from making decisions about data-structure and algorithm design, and thus allows solutions to be constructed quickly. Because DSL's are at a higher level of abstraction they are easier to maintain and reason about than equivalent programs written in a high-level language, and perhaps most importantly they can be written by domain experts rather than programmers.The problem is that DSL implementation is costly and prone to errors, and that high level approaches to DSL implementation often produce inefficient systems. By using two new programming language mechanisms, program staging and monadic abstraction, we can lower the cost of DSL implementations by allowing reuse at many levels. These mechanisms provide the expressive power that allows the construction of many compiler components as reusable libraries, provide a direct link between the semantics and the low-level implementation, and provide the structure necessary to reason about the implementation.},
journal = {ACM SIGPLAN Notices},
month = dec,
pages = {81–94},
numpages = {14}
}

@InProceedings{farmer2013quoteEval,
author="Farmer, William M.",
editor="Carette, Jacques
and Aspinall, David
and Lange, Christoph
and Sojka, Petr
and Windsteiger, Wolfgang",
title={{The Formalization of Syntax-Based Mathematical Algorithms Using Quotation and Evaluation}},
booktitle="Intelligent Computer Mathematics",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="35--50",
abstract="Algorithms like those for differentiating functional expressions manipulate the syntactic structure of mathematical expressions in a mathematically meaningful way. A formalization of such an algorithm should include a specification of its computational behavior, a specification of its mathematical meaning, and a mechanism for applying the algorithm to actual expressions. Achieving these goals requires the ability to integrate reasoning about the syntax of the expressions with reasoning about what the expressions mean. A syntax framework is a mathematical structure that is an abstract model for a syntax reasoning system. It contains a mapping of expressions to syntactic values that represent the syntactic structures of the expressions; a language for reasoning about syntactic values; a quotation mechanism to refer to the syntactic value of an expression; and an evaluation mechanism to refer to the value of the expression represented by a syntactic value. We present and compare two approaches, based on instances of a syntax framework, to formalize a syntax-based mathematical algorithm in a formal theory T. In the first approach the syntactic values for the expressions manipulated by the algorithm are members of an inductive type in T, but quotation and evaluation are functions defined in the metatheory of T. In the second approach every expression in T is represented by a syntactic value, and quotation and evaluation are operators in T itself.",
isbn="978-3-642-39320-4"
}

@book{pierce1990taste,
  title={{A Taste of Category Theory for Computer Scientists}},
  author={Pierce, Benjamin C},
  year={1990},
  publisher={Carnegie Mellon University}
}

@misc{nlab:colimit,
  author = {{nLab authors}},
  title = {colimit},
  howpublished = {\url{http://ncatlab.org/nlab/show/colimit}},
  note = {\href{http://ncatlab.org/nlab/revision/colimit/17}{Revision 17}},
  month = nov,
  year = 2020
}

@misc{nlab:pushout,
  author = {{nLab authors}},
  title = {pushout},
  howpublished = {\url{http://ncatlab.org/nlab/show/pushout}},
  note = {\href{http://ncatlab.org/nlab/revision/pushout/22}{Revision 22}},
  month = nov,
  year = 2020
}

% Implementation of combinators 
@misc{TPCProto,
  title = {{Prototype of MathScheme Combinators}},
  author = {Jacques Carette and Russell O'Connor},
  year = 2011,
  howpublished = {GitHub repository \url{https://github.com/JacquesCarette/MathScheme/tree/7f24a911790d67f5ab28db425bda1200bc0d5a45/prototype}}
}

@misc{msLibDecls,
  title = {{MathScheme Library Declarations}},
  author = {Jacques Carette and Russell O'Connor},
  year = 2011,
  howpublished = {GitHub repository \url{https://github.com/JacquesCarette/MathScheme/blob/7f24a911790d67f5ab28db425bda1200bc0d5a45/prototype/src/Algebra/Base.msl}}
}

@misc{meta-prim-blog,
  author = {Musa Al-hassy},
  title = {Making {M}odules with {M}eta-{P}rogrammed {M}eta-{P}rimitives},
  howpublished = 
  {\url{https://alhassy.github.io/next-700-module-systems/prototype/package-former.html#hundreds-of-theories}},
  year={2019},
  note = {Accessed: 2019-11-20}
}

@article{syb2003Jones,
author = {L\"{a}mmel, Ralf and Jones, Simon Peyton},
title ={{Scrap Your Boilerplate: A Practical Design Pattern for Generic Programming}},
year = {2003},
issue_date = {March 2003},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {38},
number = {3},
issn = {0362-1340},
url = {https://doi.org/10.1145/640136.604179},
doi = {10.1145/640136.604179},
abstract = {We describe a design pattern for writing programs that traverse data structures built from rich mutually-recursive data types. Such programs often have a great deal of "boilerplate" code that simply walks the structure, hiding a small amount of "real" code that constitutes the reason for the traversal.Our technique allows most of this boilerplate to be written once and for all, or even generated mechanically, leaving the programmer free to concentrate on the important part of the algorithm. These generic programs are much more adaptive when faced with data structure evolution because they contain many fewer lines of type-specific code.Our approach is simple to understand, reasonably efficient, and it handles all the data types found in conventional functional programming languages. It makes essential use of rank-2 polymorphism, an extension found in some implementations of Haskell. Further it relies on a simple type-safe cast operator.},
journal = {ACM SIGPLAN Notices},
month = jan,
pages = {26–37},
numpages = {12},
keywords = {generic programming, traversal, type cast, rank-2 types}
}

@inproceedings{brady2016reflection,
  author = {Christiansen, David and Brady, Edwin},
  title = {{Elaborator Reflection: Extending Idris in Idris}},
  year = {2016},
  isbn = {9781450342193},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2951913.2951932},
  doi = {10.1145/2951913.2951932},
  abstract = {Many programming languages and proof assistants are defined by elaboration from a high-level language with a great deal of implicit information to a highly explicit core language. In many advanced languages, these elaboration facilities contain powerful tools for program construction, but these tools are rarely designed to be repurposed by users. We describe elaborator reflection, a paradigm for metaprogramming in which the elaboration machinery is made directly available to metaprograms, as well as a concrete realization of elaborator reflection in Idris, a functional language with full dependent types. We demonstrate the applicability of Idris’s reflected elaboration framework to a number of realistic problems, we discuss the motivation for the specific features of its design, and we explore the broader meaning of elaborator reflection as it can relate to other languages.}, 
  booktitle = {Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
  pages = {284–297},
  numpages = {14},
  keywords = {dependent types, Metaprogramming, elaboration},
  location = {Nara, Japan},
  series = {ICFP 2016}
}

@misc{whyDttCoq,
    author={Jason Gross and Ken Kubota and Serge D. Mechveliani and others},  
    title={Why dependent type theory?}, 
    month={March},  
    year={2020}, 
    howPublished={\url{https://coq.discourse.group/t/why-dependent-type-theory/657}} 
}

@misc{whyDttBauer,
    author = {Andrej Bauer}, 
    title = {What makes dependent type theory more suitable than set theory for proof assistants?}, 
    date = {November 20}, 
    year = {2020},  
    note = {posted at: \url{https://mathoverflow.net/questions/376839/what-makes-dependent-type-theory-more-suitable-than-set-theory-for-proof-assista}}
}

@misc{nCatShulman,
    author = {Mike Shulman}, 
    title = {{In Praise of Dependent Types}}, 
    howpublished = {The n-Category Café blog},
    date = {March 3}, 
    year = {2010}, 
    note = {\url{https://golem.ph.utexas.edu/category/2010/03/in_praise_of_dependent_types.html}} 
}

@incollection{pierce2005advanced,
  booktitle={Advanced Topics in Types and Programming Languages},
  title={Dependent types},
  pages={45-86},
  author={David Aspinall and Martin Hofmann},
  editor={Pierce, Benjamin C},
  year={2005},
  publisher={MIT press}
}

@article{lean2017metaprogramming,
  title={{A Metaprogramming Framework for Formal Verification}},
  author={Ebner, Gabriel and Ullrich, Sebastian and Roesch, Jared and Avigad, Jeremy and de Moura, Leonardo},
  journal={Proceedings of the ACM on Programming Languages},
  volume={1},
  number={ICFP},
  pages={1--29},
  year={2017},
  publisher={ACM New York, NY, USA}
}

@mastersthesis{van2012reflection,
  title={{Reflection in Agda}},
  author={van der Walt, PD},
  school={Utrecht University}, 
  year={2012}
}

@misc{agdaReflection,
  title = {Allow metaprogramming to generate top level definitions other than functions},
  author={Dylan Ede},
  month={April},
  year={2019}, 
  howPublished = {Github issue 3699: \url{https://github.com/agda/agda/issues/3699}}, 
  note={Accessed: December 2,2020}
}

@inproceedings{templateCoq2018,
  TITLE = {{Towards Certified Meta-Programming with Typed Template-Coq}},
  AUTHOR = {Anand, Abhishek and Boulier, Simon and Cohen, Cyril and Sozeau, Matthieu and Tabareau, Nicolas},
  URL = {https://hal.archives-ouvertes.fr/hal-01809681},
  BOOKTITLE = {{ITP 2018 - 9th Conference on Interactive Theorem Proving}},
  ADDRESS = {Oxford, United Kingdom},
  HAL_LOCAL_REFERENCE = {ACTI+},
  PUBLISHER = {{Springer}},
  SERIES = {LNCS},
  VOLUME = {10895},
  PAGES = {20-39},
  YEAR = {2018},
  MONTH = Jul,
  DOI = {10.1007/978-3-319-94821-8\_2},
  PDF = {https://hal.archives-ouvertes.fr/hal-01809681/file/paper_39.pdf},
  HAL_ID = {hal-01809681},
  HAL_VERSION = {v1},
}

@article{metcCoq2018,
author = {Kaiser, Jan-Oliver and Ziliani, Beta and Krebbers, Robbert and R\'{e}gis-Gianas, Yann and Dreyer, Derek},
title = {Mtac2: Typed Tactics for Backward Reasoning in Coq},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236773},
doi = {10.1145/3236773},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {78},
numpages = {31},
keywords = {Metaprogramming, Tactic Languages, Dependent Types, Theorem Proving, Coq}
}

@InProceedings{inversPrincp1996Coq,
author={Cornes, Cristina and Terrasse, Delphine},
editor={Berardi, Stefano and Coppo, Mario},
title={{Automating Inversion of Inductive Predicates in Coq}},
booktitle="Types for Proofs and Programs",
year="1996",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="85--104",
abstract="An inductive definition of a set is often informally presented by giving some rules that explain how to build the elements of the set. The closure property states that any object is in the set if and only if it has been generated according to the formation rules. This is enough to justify case analysis reasoning: we can read the formation rules backwards to derive the necessary conditions for a given instance to hold. The problem of inversion consists in finding out these conditions.",
isbn="978-3-540-70722-6"
}

@article{blanchette2016hammering,
  title={{Hammering towards QED}},
  author={Blanchette, Jasmin Christian and Kaliszyk, Cezary and Paulson, Lawrence C and Urban, Josef},
  journal={Journal of Formalized Reasoning},
  volume={9},
  number={1},
  pages={101--148},
  year={2016}
}

@article{czajka2018hammer,
  title={{Hammer for Coq: Automation for dependent type theory}},
  author={Czajka, {\L}ukasz and Kaliszyk, Cezary},
  journal={Journal of Automated Reasoning},
  volume={61},
  number={1-4},
  pages={423--453},
  year={2018},
  publisher={Springer}
}

@InProceedings{Gibbons2007DGP,
	author="Gibbons, Jeremy",
	editor="Backhouse, Roland
	and Gibbons, Jeremy
	and Hinze, Ralf
	and Jeuring, Johan",
	title="Datatype-Generic Programming",
	booktitle="Datatype-Generic Programming",
	year="2007",
	publisher="Springer Berlin Heidelberg",
	address="Berlin, Heidelberg",
	pages="1--71"
}

@incollection{hinze2007comparing,
	title={Comparing approaches to generic programming in Haskell},
	author={Hinze, Ralf and Jeuring, Johan and L{\"o}h, Andres},
	booktitle={Datatype-Generic Programming},
	pages={72--149},
	year={2007},
	publisher={Springer}
}

@Inbook{Hinze2003GenericHs,
	author="Hinze, Ralf
	and Jeuring, Johan",
	editor="Backhouse, Roland
	and Gibbons, Jeremy",
	title="Chapter 1. Generic Haskell: Practice and Theory",
	bookTitle="Generic Programming: Advanced Lectures",
	year="2003",
	publisher="Springer Berlin Heidelberg",
	address="Berlin, Heidelberg",
	pages="1--56"
}

@inproceedings{Jansson1997PolyP,
	author = {Jansson, Patrik and Jeuring, Johan},
	title = {PolyP\&Mdash;a Polytypic Programming Language Extension},
	booktitle = {Proceedings of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
	series = {POPL '97},
	year = {1997},
	isbn = {0-89791-853-3},
	location = {Paris, France},
	pages = {470--482},
	numpages = {13},
	url = {http://doi.acm.org/10.1145/263699.263763},
	doi = {10.1145/263699.263763},
	acmid = {263763},
	publisher = {ACM},
	address = {New York, NY, USA}
} 

@inproceedings{winstanley1997type,
	title={A type-sensitive preprocessor for Haskell},
	author={Winstanley, Noel},
	booktitle={Glasgow Workshop on Functional Programming, Ullapool},
	year={1997},
	organization={Citeseer}
}

@InProceedings{Norell2004TemplateHs,
	author="Norell, Ulf
	and Jansson, Patrik",
	editor="Kozen, Dexter",
	title="Prototyping Generic Programming in Template Haskell",
	booktitle="Mathematics of Program Construction",
	year="2004",
	publisher="Springer Berlin Heidelberg",
	address="Berlin, Heidelberg",
	pages="314--333" 
}

@misc{Dowek2019LogipediaAM,
  title={{Logipedia: a multi-system encyclopedia of formal proofs}},
  author={G. Dowek and François Thir{\'e}},
  year={2019},
  note={\url{http://www.lsv.fr/~dowek/Publi/logipedia.pdf}}
}


@article{lem2014,
    title={{Lem: Reusable Engineering of Real-world Semantics}},
    author={Dominic P. Mulligan and Scott Owens and Kathryn E. Gray and Tom Ridge and Peter Sewell},
    journal={ACM SIGPLAN Notices},
    volume={49},
    number={9},
    pages={175--188},
    year={2014},
    publisher={ACM New York, NY, USA}
}

@misc{ocaml2019ppx, 
  author = {Rebours, Nathan},
  title = {{An Introduction to OCaml PPX Ecosystem}}, 
  month = {May},
  year = {2019},
  howpublished = {Tutorial: \url{https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem}}, 
  note = {Accessed on December 2020}
}

@inproceedings{firsov2018generic,
  title={Generic derivation of induction for impredicative encodings in Cedille},
  author={Firsov, Denis and Stump, Aaron},
  booktitle={Proceedings of the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  pages={215--227},
  year={2018}
}

@article{macros2001msp,
author = {Ganz, Steven E. and Sabry, Amr and Taha, Walid},
title = {{Macros as Multi-Stage Computations: Type-Safe, Generative, Binding Macros in MacroML}},
year = {2001},
issue_date = {October 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {36},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/507669.507646},
doi = {10.1145/507669.507646},
abstract = {With few exceptions, macros have traditionally been viewed as operations on syntax trees or even on plain strings. This view makes macros seem ad hoc, and is at odds with two desirable features of contemporary typed functional languages: static typing and static scoping. At a deeper level, there is a need for a simple, usable semantics for macros. This paper argues that these problems can be addressed by formally viewing macros as multi-stage computations. This view eliminates the need for freshness conditions and tests on variable names, and provides a compositional interpretation that can serve as a basis for designing a sound type system for languages supporting macros, or even for compilation. To illustrate our approach, we develop and present MacroML, an extension of ML that supports inlining, recursive macros, and the definition of new binding constructs. The latter is subtle, and is the most novel addition in a statically typed setting. The semantics of a core subset of MacroML is given by an interpretation into MetaML, a statically-typed multi-stage programming language. It is then easy to show that MacroML is stage- and type-safe: macro expansion does not depend on runtime evaluation, and both stages do not "go wrong.},
journal = {ACM SIGPLAN Notices},
month = oct,
pages = {74–85},
numpages = {12}
}

@article{cartmell1986gats,
title = {{Generalised Algebraic Theories and Contextual Categories}},
journal = "Annals of Pure and Applied Logic",
volume = "32",
pages = "209 - 243",
year = "1986",
issn = "0168-0072",
doi = "https://doi.org/10.1016/0168-0072(86)90053-9",
url = "http://www.sciencedirect.com/science/article/pii/0168007286900539",
author = "John Cartmell"
}

@inproceedings{cicm2019docotral,
  author = {Yasmine Sharoda}, 
  title = {{Leveraging Information Contained in Theory Presentations}}, 
  year = {2019},
  publisher = {CEUR Workshop Proceedings}, 
  volume = {2634}, 
  booktitle={Workshop Papers at 12th Conference on Intelligent Computer Mathematics CICM 2019},
  note = {\url{http://ceur-ws.org/Vol-2634/DP7.pdf}}
}

@inproceedings{reynolds1983types,
  title={Types, abstraction and parametric polymorphism},
  author={Reynolds, John C},
  booktitle={Information Processing 83, Proceedings of the IFIP 9th World Computer Congres},
  pages={513--523},
  year={1983}
}

@article{BIRKEDAL19993,
title = "Relational Interpretations of Recursive Types in an Operational Setting",
journal = "Information and Computation",
volume = "155",
number = "1",
pages = "3 - 63",
year = "1999",
issn = "0890-5401",
doi = "https://doi.org/10.1006/inco.1999.2828",
url = "http://www.sciencedirect.com/science/article/pii/S0890540199928286",
author = "Lars Birkedal and Robert Harper"
}

@article{bernardy2012proofs,
  title={Proofs for free-parametricity for dependent types},
  author={Bernardy, Jean-Philippe and Jannson, P and Paterson, RA},
  journal={Journal of Functional Programming},
  volume={22},
  number={2},
  pages={107--152},
  year={2012},
  publisher={Cambridge University Press}
}

@InBook{crary2005logical,
  author = {Karl Crary},
  editor = {Benjamin Pierce},
  title = {Logical Relations and a Case Study in Equivalence Checking},
  chapter = {6},
  publisher = {MIT Press, Cambridge, MA},
  year = {2005},
  pages = {223--244}
}

@article{poplmark2019, 
   title={POPLMark reloaded: Mechanizing proofs by logical relations}, 
   volume={29}, 
   DOI={10.1017/S0956796819000170}, 
   journal={Journal of Functional Programming}, 
   publisher={Cambridge University Press}, 
   author={Abel, Andreas and Allais, Guillaume and Hameer, Aliya and Pientka, Brigitte and 
   Momigliano, Alberto and Schäfer, Steven and Stark, Kathrin}, 
   year={2019} 
}

