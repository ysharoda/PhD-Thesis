\chapter{Theory Development Practice}
\label{ch:redundancy}

The formal systems community has mostly focused on making necessary things possible. Our focus is more oriented to making uniform definitions free. In this chapter we highlight the redundancy that is currently a part of the development of theories in formal systems. In Section~\ref{sec:redun:libraries} we focus our attention to libraries of formal systems, while in Section~\ref{sec:redun:user_projects} we show how some projects are redfines algebraic structure and some other constructions because they are unable to use the definitions provided by libraries of the system they are using. 

\section{Algebra Theories in Libraries}\ednote{currently a copy-paste from the paper}
\label{sec:redun:libraries}

One of our observations is that current formalizations of Algebra contain quite a
bit of information that is ``free'' in the sense that it can be
mechanically generated from basic definitions. For example, given a theory
X, it is mechanical to define X-homomorphisms. To do this within a system
is extremely difficult, as it would require introspection and for theory
\emph{definitions} to be first-class citizens, which is not the case for any
system based on type-theory that we are aware of. Untyped systems
in the Lisp tradition do this routinely, as does Maude~\cite{Maude}, which
is based on \emph{rewriting logic}; the downside is that there is no
difference between meaningful and meaningless transformations in these
systems, only between ``runs successfully'' and ``crashes''. However,
these constructions are fully typeable and, moreover, are not system-specific
(as they can be phrased meta-theoretically within Universal
Algebra), even though an implementation has to be aware of the syntactic
details of each system.

Lest the reader think that our quest is a little quixotic, we first look at
current libraries from a variety of systems, to find concrete examples of
human-written code that could have been generated. We look at Agda,
Isabelle/HOL and Lean in particular. More specifically, we look at
\href{https://github.com/agda/agda-stdlib/releases/tag/v1.3}
{version 1.3 of the Agda standard library},
the \href
{https://isabelle.in.tum.de/website-Isabelle2019/dist/library/HOL/HOL-Algebra/index.html} 
{2019 release of the Isabelle/HOL library}
and 
\href
{https://github.com/leanprover-community/mathlib/releases/tag/snapshot-2019-10}
{Lean's mathlib}, where we link to the proper release tag.

We use the theory \verb|Monoid| as our running example, and we 
highlight the reusable components that the systems use to make writing the
definitions easier and more robust. 

\subsection{Homomorphism}
How do the libraries of our three systems\footnote{We do not have enough room
    to give an introduction to each system; hopefully each system's syntax is
    clear enough for the main ideas to come through.}
represent homomorphism?

\subsubsection{Agda}
defines \lstmath{Monoid} homomorphism, indirectly, in two ways. First,
a predicate encapsulating the proof obligations is defined, which is
layered on top of the predicate for 
\href
{https://github.com/agda/agda-stdlib/blob/4a8d8f5ffbdbd967ca1bb708895ea63709e0063d/src/Algebra/Morphism.agda} 
{Semigroup homomorphism}.
This is then used to define homomorphisms themselves.

\begin{agdacode}
module _ {c~$_1$~ ~$\ell_1$~ c~$_2$~ ~$\ell_2$~}
(From : Monoid c~$_1$~ ~$\ell_1$~)
(To   : Monoid c~$_2$~ ~$\ell_2$~) where

private
module F = Monoid From
module T = Monoid To

record IsSemigroupMorphism (~$\llbracket$~_~$\rrbracket$~:Morphism)
: Set(c~$_1$~ ~$\sqcup$~ ~$\ell_1$~ ~$\sqcup$~ c~$_2$~ ~$\sqcup$~ ~$\ell_2$~) where 
field
~$\llbracket\rrbracket$~-cong : ~$\llbracket$~_~$\rrbracket$~ Preserves F._~$\approx$~_ ~$\to$~ T._~$\approx$~_
~$\bigdot$~-homo  : Homomorphic~$_2$~ ~$\llbracket$~_~$\rrbracket$~ F._~$\bigdot$~_ T._~$\bigdot$~_
~$\cdots$~
record IsMonoidMorphism (~$\llbracket$~_~$\rrbracket$~:Morphism)
: Set(c~$_1$~ ~$\sqcup$~ ~$\ell_1$~ ~$\sqcup$~ c~$_2$~ ~$\sqcup$~ ~$\ell_2$~) where 
field
sm-homo : IsSemigroupMorphism F.semigroup T.semigroup ~$\llbracket$~_~$\rrbracket$~
~$\varepsilon$~-homo   : Homomorphic~$_0$~ ~$\llbracket$~_~$\rrbracket$~ F.~$\varepsilon$~ T.~$\varepsilon$~

open IsSemigroupMorphism sm-homo public
\end{agdacode}

There are many design decisions embedded in the above definitions. These
decisions are not canonical, so we need to understand them to later
be able to both abstract them out and make them variation points in our
generator. Namely, these decisions are:
\begin{itemize}
    \item The choice of which declarations are parameters and which are fields.
    The monoids (\verb|From| and \verb|To|) over which we define homomorphism
    are parameters, not fields, as is the function
    \lstinline[mathescape]|$\llbracket$_$\rrbracket$|.
    \item The preservation axioms can be defined based on their arity
    patterns, as type-level function such as
    \lstinline[mathescape]|Homomorphic$_{2}$|:
    \begin{agdacode}
Homomorphic~$_{2}$~ : (A ~$\to$~ B) ~$\to$~ Op~$_2$~ A ~$\to$~ Op~$_2$~ B ~$\to$~ Set _ 
Homomorphic~$_{2}$~ ~$\llbracket$~_~$\rrbracket$~ _~$\bigdot$~_ _~$\circ$~_ =
  ~$\forall$~ x y ~$\to$~ ~$\sembr{\text{ x } \bigdot \text{ y }}$~ ~$\approx$~ (~$\sembr{\text{ x }}$~ ~$\circ$~ ~$\sembr{\text{ y }}$~)
    \end{agdacode}
    The library also provides shortcuts for $0$-ary and $1$-ary function
    symbols, the most common cases.
    \item The definition of structures over setoids. Thus equalities need 
    to be preserved, and that is what the 
    \lstinline[mathescape]|$\llbracket\rrbracket$-cong| axiom states.
\end{itemize}

\subsubsection{Isabelle/HOL}
provides the following definition of \href{https://isabelle.in.tum.de/website-Isabelle2019/dist/library/HOL/HOL-Algebra/Group.html}{monoid homomorphism}:

\begin{isabellecode}
definition  _ ~$\Rightarrow$~ _ ~$\Rightarrow$~ ('a ~$\Rightarrow$~ 'b) set where 
hom G H =
  {h ~$\cdot$~ h ~$\in$~ carrier G ~$\to$~ carrier H ~$\wedge$~ 
  (~$\forall$~ x ~$\in$~ carrier G ~$\cdot$~ ~$\forall$~ y ~$\in$~ carrier G  ~$\cdot$~ 
    h (x ~$\oplus_\text{G}$~ y) = h x ~$\oplus_\text{H}$~ h y)}
\end{isabellecode}
\ednote{The problem of minted accpeting double quotes}

The reader might notice a discrepancy in the above: unit preservation is
missing.  The Isabelle library does not provide this version.
There is, however, a proof that such a multiplication-preserving homomorphism
necessarily maps the source unit to a unit of the image (sub)monoid, but that
unit is not necessarily that of the full image. The above definition is also
used to define group homomorphism and other structures. We consider
this to be missing information in the library. 


\subsubsection{Lean}\hspace{-0.4em}'s
definition of \href{https://github.com/leanprover-community/mathlib/blob/3c58f160fd51ebf989138ed7c8981f821f08f860/src/algebra/group/hom.lean}
{monoid homomorphism}
is the one that most resembles the one found in textbooks. 
\begin{leancode}
structure monoid_hom (M : Type*) (N : Type*) 
[monoid M] [monoid N] :=
(to_fun : M ~$\to$~ N)
(map_one' : to_fun 1 = 1)
(map_mul' : ~$\forall$~ x y, to_fun (x * y) = to_fun x * to_fun y)
\end{leancode}

However, in the same file, there is another definition of \verb|add_monoid_hom| that looks ``the same'' up to renaming. This points
to a weakness of Lean: there is no renaming operation on 
\verb|structure|, and for a \verb|Ring| to contain two ``monoids'', one
is forced to duplicate definitions. This redundancy is unpleasant.

\subsection{Term Language}

The ``term language'' of a theory is the (inductive) data type
that represents the syntax of well-formed terms of that theory,
along with an interpretation function from \emph{expressions} 
to the carrier of the (implicitly single-sorted) given theory, i.e.
its denotational semantics.

In Agda, the definition of \lstinline|Monoid| term language is straightforward:
\begin{agdacode}
data Expr (n : ~$\mathbb{N}$~) where 
var : Fin n ~$\to$~ Expr n 
id : Expr n 
_~$\oplus$~_ : Expr n ~$\to$~ Expr n ~$\to$~ Expr n 
\end{agdacode}
Defining the interpretation function requires the concept of an environment.
An environment associates a value to every variable, and the semantics
associates a value (of type \verb|Carrier|) to each expression of \verb|Expr|.
\begin{agdacode}
Env : Set _ 
Env = ~$\lambda$~ n ~$\rightarrow$~ Vec Carrier n 

~$\llbracket$~_~$\rrbracket$~ : ~$\forall$~ {n} ~$\to$~ Expr n ~$\to$~ Env n ~$\to$~ Carrier 
~$\llbracket$~ var x ~$\rrbracket$~ ~$\upvarrho$~ = lookup ~$\upvarrho$~ x 
~$\llbracket$~ id ~$\rrbracket$~ ~$\upvarrho$~ = ~$\epsilon$~ 
~$\llbracket$~ e~$_1$~ ~$\oplus$~ e~$_2$~ ~$\rrbracket$~ ~$\upvarrho$~ = ~$\llbracket$~ e~$_1$~ ~$\rrbracket$~ ~$\upvarrho$~ ~$\cdot$~ ~$\llbracket$~ e~$_2$~ ~$\rrbracket$~ ~$\upvarrho$~ 
\end{agdacode}


In Agda, these definitions are not found with the definitions of the
algebraic structures themselves, but rather as part of the
\emph{Solver} for equations over that theory. Here, we find more
duplication, as the above definitions
are repeated for the following three highly related structures: 
\href{https://github.com/agda/agda-stdlib/blob/4a8d8f5ffbdbd967ca1bb708895ea63709e0063d/src/Algebra/Solver/Monoid.agda}
{\lstinline|Monoid|},
\href{https://github.com/agda/agda-stdlib/blob/4a8d8f5ffbdbd967ca1bb708895ea63709e0063d/src/Algebra/Solver/CommutativeMonoid.agda}
{\lstinline|CommutativeMonoid|}
and 
\href{https://github.com/agda/agda-stdlib/blob/4a8d8f5ffbdbd967ca1bb708895ea63709e0063d/src/Algebra/Solver/IdempotentCommutativeMonoid.agda}
{\lstinline|IdempotentCommutativeMonoid|}.

Despite its usefulness, we were not able to find the definition of the term
language of a theory in Isabelle/HOL or Lean.  

\subsection{Product}
Until recently, there was no definition of the product of algebraic
structures in the Agda library.  A 
\href{https://github.com/agda/agda-stdlib/pull/1109}{recent pull request}
has suggested adding these, along with other constructions.  The
following hand-written definition has now been added:
\begin{agdacode}
rawMonoid : RawMonoid c c~$\ell$~ ~$\to$~ RawMonoid d d~$\ell$~ ~$\to$~ 
RawMonoid (c ~$\sqcup$~ d) (c~$\ell$~ ~$\sqcup$~ d~$\ell$~)
rawMonoid M N = record
{ Carrier = M.Carrier ~$\times$~ N.Carrier
; _~$\approx$~_ = Pointwise M._~$\approx$~_ N._~$\approx$~_
; _~$\bigdot$~_ = zip M._~$\bigdot$~_ N._~$\bigdot$~_
; ~$\varepsilon$~ = M.~$\varepsilon$~ , N.~$\varepsilon$~
}
where
module M = RawMonoid M
module N = RawMonoid N
\end{agdacode}

These could have been mechanically generated from the definition
of \verb|Monoid|.

Both 
\href{https://isabelle.in.tum.de/website-Isabelle2019/dist/library/HOL/HOL-Algebra/Group.html}
{Isabelle/HOL}
and 
\href{https://github.com/leanprover-community/mathlib/blob/3c58f160fd51ebf989138ed7c8981f821f08f860/src/algebra/pi_instances.lean}
{Lean}
provide definitions of product algebras for monoids, which we omit for space.
It is worth mentioning that the Lean library has $15$ definitions for products
of structures that look very similar and could be generated. 


\section{Algebra Theories in User Projects}
\label{sec:redun:user_projects}

We continue investigating the redundancy in code written by developers. In the previous section we looked into general purpose libraries. We now turn our attention to user projects highlighting the cases when users had to redefine information already existing in libraries. 

The theories and data structures project~\cite{theoriesAndDts}, implemented in Agda, explores how algebraic theories give rise to some common data structures. A natural first step is to formalize the algebraic theories of interest to the project. Despite the existence of some of these algebraic structures in the standard library, like the \lstmath{Monoid} theory with the definition above, the project developers redefined many of them~\footnote{https://github.com/JacquesCarette/TheoriesAndDataStructures/tree/master/Structures}, like \lstmath{Magma, }\lstmath{Monoid}, \lstmath{CommMonoid}, and \lstmath{AbelianGroup}. In some cases, like in \lstmath{Monoid}, the definitions avoided setoids, while in others, like in \lstmath{CommMonoid} it used it. This highlights how important it is to provide a way of customizing definitions while using them. 

The MGG project~\cite{carette2011generative} deals with the computational geometry software as a family of programs and aim to define abstractions from which different software pieces can be generated. One of the layers common to many members of this software family is algebra. In \lstmath{Algebra.lhs} the finally tagless representation of many algebraic structures are given as follows 
\begin{hscode}
class Monoid repr n where
  add :: repr n -> repr n -> repr n
  zero :: repr n

class Monoid repr n => AdditiveGroup repr n where
  neg :: repr n -> repr n
  sub :: repr n -> repr n -> repr n
  int_pow :: Integer -> repr n -> repr n
  of_int :: Integer -> repr n
\end{hscode}
We show in Chapter~\ref{ch:generation} that the finally tagless representation can be generated. Another form of redundancy, is defining the \lstmath{Monoid} instance of various number representations, like float, integer and rational, along with the code and staged versions. For example, in Float.lhs, we find the following definition 
\begin{hscode}
instance Monoid BaseImm Double where
  add = liftA2 (+)
  zero = pure (0.0)

instance Monoid Code Double where
  add (Code x) (Code y) = Code [| $(x) + $(y) |]
  zero = Code [| 0.0 |]

instance Monoid Staged Double where
  add a b = monoid Alg.zero add add a b
  zero = of_atom (0.0)
\end{hscode}
with instances of the three version of \lstmath{Double} for \lstmath{Field}, \lstmath{AdditiveGroup}, \lstmath{Norm}, and \lstmath{Ring}. The same definitions in repeated for \lstmath{Integer} type in Integer.lhs file. 
\begin{hscode}
instance Monoid BaseImm Integer where
  add = liftA2 (+)
  zero = pure 0

instance Monoid Code Integer where
  add (Code x) (Code y) = Code [| $(x) + $(y) |]
  zero = Code [| 0 |]

instance Monoid Staged Integer where
  zero = of_atom $ 0
  add = monoid A.zero add add
\end{hscode}
and for rationals in Rational.lhs\ednote{Problem with this example is the repo has limited accessibility.}


