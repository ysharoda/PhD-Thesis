\chapter{Constructions For Free!}
\label{ch:generation}

\section{What can be generated}
Given a theory presentation \lstmath{(S,F,E)} in first order equational logic, The following constructions can be generated 
\begin{itemize}
    \item Signature 
    \item Product theory 
    \item Project from a product theory 
    \item SubTheory 
    \item Trivial SubTheory 
    \item The theory of subsets of the carrier 
    \item Homomorphisms 
    \item Isomorphisms 
    \item Monomorphism 
    \item Endomorphism 
    \item Automorphism 
    \item Epimorphism 
    \item The kernel of a morphism 
    \item The composition of morphisms 
    \item Homomorphism Equality 
    \item Congruence relations 
    \item Quotient Algebras
    \item Monotonicity proofs 
    \item Closed term language 
    \item Open term language 
    \item Staged term language 
    \item Structural induction 
    \item Evaluation functions 
    \item Simplification via rewriting 
    \item Structural induction 
    \item Equivalence of terms 
    \item Applying functors to terms 
    \item Setters and getters for instances of data types (lenses in Haskell) 
    \item Theory Actions 
    \item Subset Actions
    \item Coset of a theory 
\end{itemize}

\section{Basic Ingredients}

Meta programs 

In order to develop a meta program that generates the constructions above, and possible more, we need a way to manipulate theory presentations, i.e. a program that given a theory presentation would generate theories, types, and functions representing the constructions above. Therefore, the program 


equality, substitution, .. 

The theoretical background of our work is taken from Universal Algebra. 

Starting from theories of universal algebra, we aim to design a framework to generate useful constructions. To achieve this, our first step is to find a language to represent equational theories and other constructions, and a type checker to make sure the generated constructions are correct. While looking for this system we had the following criteria in mind 

\begin{itemize}
 \item A small language 
 \item Little syntactic sugar 
 \item Support record, data and function declarations 
 \item Dependently typed \ednote{we originally wanted a DTT-based system to be able to talk about the arrows. We didn't end up doing that - all work on the arrows is at the metalanguage (haskell), not the object one (tog). Now, there is no real reason why we need DTT. }
\end{itemize}

\ednote{Motivate the decision to use Tog}

To investigate what information can be derived from an equational theory, we needed to internalize it within a language and a type checker. One of our core decisions is to find a minimal

\section{Syntax}
Tog is a dependent type language that has a syntax similar to Agda, Coq and Idris, with much less sugar. 
\subsection{Expressions}
\subsubsection{Types}

\subsubsection{Functions}

\subsection{Declaration}
\subsubsection{Record}

\subsubsection{Data Types}

\subsubsection{Functions}