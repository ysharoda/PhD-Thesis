\chapter{Constructions For Free!}
\label{ch:generation}

The flattener interprets theory expressions into a graph of flat theories and morphisms between them. The resulting flat theories are then used by the generator to produce some useful tools (constructions) related to them. In this chapter, we introduce the generator and answer the first and second research questions imposed in Section~\ref{sec:questions}.

We define some meta programs written in haskell (the meta language) to generate tog (the object language) definitions. 
The input to these programs are flat theory presentations in DTT. We know that those theories describe algebraic structures and therefore they can be represented in unisorted equational lo as described by universal algebra. In Chapter~\ref{ch:ualgebra} we introduced theories and their related constructions in universal algebra. Here we discuss our framework that uses this knowledge to generate information from theory presentations. We use the haskell type \lstmath{EqTheory} to describe the structure of equational theories. Because this type is built using the tog abstract syntax, manipulating it is more or less manipulating tog syntax. The output of the generator is guaranteed to be well-formed. The tog type checker is run on this input to check for well-typedness. 

%In Section~\ref{sec:toBeGenerated} we introduce a list of operations that can be generated from flattened theory presentations. 
In Section~\ref{sec:togFamework} we introduce the basic components of our framework. We use these components to generate some of the constructions in the list of Section~\ref{sec:toBeGenerated}. We discuss the generation algorithms in Section~\ref{sec:generatedConstructions}. 

\section{Tog Framework}
\label{sec:togFamework}
With so many construction to be generated, we develop an infrastructure that can be used to generate them. The main component is the type \lstmath{EqTheory}, which is a representation of uni-sorted equational theories described in Secion~\ref{subsec:generation:eqTheories}. 
In order to operate on equational theories and generate the constructions we are interested in, we provide some utilities to manipulate tog representation of functions and datatypes in Sections~\ref{subsec:generation:functions} and~\ref{subsec:generation:datatypes}, resepectively. 
%Another important operation that we use in the generator is renaming, which we discuss in Section~\ref{subsec:generation:renaming}. 
Some of the definitions we generate may depend on definitions of standard operations, like looking up a value in a vector. We discuss how to add definitions to a prelude in Section~\ref{subsec:generation:prelude}. 

%As we discussed in Chapter~\ref{ch:tog}, Tog provides us with the internal representations of dependent records, which we use to represent theories. We extend the Tog implementation to generate algebraic constructions by providing metaprograms that operate on Tog internal representation of dependent records. In this section we discuss some of the basic utiities that we use in the generation algorithms. 

\subsection{Equational Theories}
\label{subsec:generation:eqTheories}
An equational theory in universal algebra abstracts over theory presentations of algebraic structures and consists of a sort, a list of function symbols and a list of axioms, as discussed in Section~\ref{sec:background:theory}. We capture this definition of equational theories by the type \lstmath{EqTheory}. 
\begin{hscode}
data EqTheory = EqTheory {
  _thyName    :: Name_  ,   -- the name of the theory 
  _sort       :: Constr ,      
  _funcTypes  :: [Constr], -- function symbols 
  _axioms     :: [Constr],
  _waist      :: Int }     -- the number of parameters 
\end{hscode}
The \lstmath{waist} is used in the same way as in \lstmath{GTheory} from Section~\ref{sec:impl:expressions}. 

The input to the generator is a list of tog dependent records representing the flattened theories described by the combinators as presented in the previous chapter. The first step the generator needs to do is to cast them into instances of \lstmath{EqTheory}, i.e. deal with a DTT context as an equational logic theory. 
\begin{comment}
This is done using the function \lstmath{recordToEqTheory}. 
\begin{hscode}
recordToEqTheory :: TRecord -> Eq.EqTheory
recordToEqTheory record@(TRecord nm params _) =
  Eq.build (nm^.name) 
    (getRecordSort record)
    (getRecordComps isFunc record)
    (getRecordComps isAxiom record)
    (paramsNum params)
\end{hscode}
In tog, records definitions are declared using the \lstmath{Record} constructor of the type \lstmath{Decl}, which contains many other constructors used to define functions, types, and others. We prefer to use a type dedicated to records, and therefore use the \lstmath{TRecord} type instead. \lstmath{TRecord} has the exact same parameters as the \lstmath{Record} constructor. 
\end{comment}

We define an instance of an \lstmath{EqTheory} in terms of its name, the bindings that constitute its parameters and the expression representing the type of this instance. 
\begin{hscode}
type EqInstance = (Name_,[Binding],Expr) 
\end{hscode}
Instances are computed by the function 
\begin{hscode} 
eqInstance :: EqTheory -> Maybe Int -> EqInstance
\end{hscode}
where the second argument is used to index the instance in cases where more than one is needed, like with the parameters of homomorphisms. The bindings of the instance are computed based on the arguments. 
\begin{hscode}
 indexBindings True i ~$\$$~ map fldsToHiddenBinds (args thry)
\end{hscode}
The expression denoting the type of the instance is an application of the name of the type to the bindings, as follows 
\begin{hscode}
 App ~$\$$~ mkArg (thry ^. thyName) : map mkArg bnames
\end{hscode} 
where \lstmath{thyName} and \lstmath{bnames} are the names of the theory and the bindings as described by the first and second elements of \lstmath{EqInstance}, respectively. 

Instances of a theory would also contain fields corresponding to those in the theory presentation. Instead of having this as part of the type of the instances, we provide functions \lstmath{projectConstr} and \lstmath{applyProjConstr} to compute them. 
%When projecting a member from a record, be it a representation of a theory or an instance, one might want to have the projected member as a type declaration or as a term in the language. 
The function \lstmath{projectConstr} provides the projected member type declaration, while \lstmath{applyProjConstr} provides the term corresponding to it. 
In both cases, the function needs to check if the declaration being projected is an argument or a field of the record. In case it is an argument, then its name in the list of bindings is used to refer to it. If not, then it needs to be qualified by the instance name. 
\begin{hscode} 
 if isArg thry c then App [mkArg ~$\$$~ findInBindings binds c]
 else App [mkArg (n ^. name), mkArg instName]
\end{hscode} 
When constructing a term using that member, we need to also generate the binding for the variables in the term. The function \lstmath{applyProjConstr} returns a tuple \lstmath{([Binding],Expr)} represnting the two components. As we work in a uni-sorted setup, we know all bindings have the type of the carrier, which we project using the \lstmath{projectConstr} function. The expression is constructed by projecting the member and applying it to the bindings using the \lstmath{App} constructor. 
\begin{hscode} 
let vars = case varName of
       Nothing -> genVars ~$\$$~ farity typ
       Just s -> genVarsWSymb s ~$\$$~ farity typ
     bindingsType = projectConstr thry i (thry ^. sort) 
in  ([HBind (map mkArg vars) bindingsType],
      App ~$\$$~ (Arg ~$\$$~ projectConstr thry i c) : map mkArg vars) 
\end{hscode} 
\lstmath{varName} allows choosing the name of the variables used in the term. If \lstmath{varName} is set to \lstmath{x}, then the bindings are \lstmath{x$_1$ ... x$_n$} where $n$ is arity of the declaration. 

%The input to this function is the definition of the theory, and in some cases an integer number. This is useful in case many instances of the theory are needed, and so they are indexed by number. The instance is represented as a tuple of two components \lstmath{([Binding],Expr)}. The \lstmath{Binding} list is useful when the theory has parameter, i.e.: \lstmath{waist > 0}. In this case the  bindings are the arguments to the theory instance. The \lstmath{Expr} corresponds to the instance expression of the theory. The instance expression is represented using the constructor \lstmath{App [Expr]}, where the first element of the list is the constructor. If there are any arguments, they follow after it. 

\subsection{Functions}
\label{subsec:generation:functions}
Our generation algorithms manipulates function symbols in different ways. It is essential to provide the key tools for this manipulation. A function symbol as a member of a theory has the type \lstmath{Constr}. It contributes to the terms in the language of the theory based on its arity. The arguments to the terms are bindings, and that's why we define the type \lstmath{FApp} of function application to variables, as follows 
\begin{hscode}
type FType = Constr
type FApp = ([Binding],Expr)
\end{hscode}
A function application is generated by \lstmath{fapp}. The types of all the bindings is set to be the sort of the theory. The expression is the name of the constr applied to its arguments 
\begin{hscode} 
 if (arity == 0) then ([],App [mkArg nm])
 else ([HBind (map mkArg vars) (etyp typ)],
            App ~$\$$~ mkArg nm : map mkArg vars)   
\end{hscode} 
%\lstmath{vars} is the list of variables generated according to the arity of the function symbol. Their types are determined based on the type of any of the arguments of the function. As we work in a unisorted environment, we don't need to check the types of all function arguments. 

One common operation on functions is pattern matching. We define the type class \lstmath{mkPattern} and its two instances for \lstmath{FType} and \lstmath{Expr}. 
\begin{hscode}
class MkPattern a where
  mkPattern :: a -> Pattern
\end{hscode} 
The pattern depends on the arity of the function symbol, and is generally the application of the name of the function symbol to its parameters. 
\begin{hscode} 
 if (arity == 0)
 then IdP ~$\$$~ mkQName nm 
 else ConP (mkQName nm) ~$\$$~ map (IdP . mkQName) vars 
\end{hscode} 

The functions \lstmath{functor} and \lstmath{functor'} supports applying a functor to an expression, be it the name of a function symbol, or a more complex expressions.

\subsection{Datatypes}
\label{subsec:generation:datatypes}
Some of the constructions that can be generated from theory presentations are represented as datatypes, like term languages. A datatype in tog has the type \lstmath{Decl}. The type \lstmath{DTInst} captures the instances of a datatype in the same way as \lstmath{EqInstance}.
Similar to functions, we deal with datatypes in two different forms, definitions and instances. 
\begin{hscode}
type DTDef = Decl
type DTInstance = (Name_,[Binding],Expr) 
\end{hscode}
Instances are computed by the function \lstmath{tinstance}. The bindings are computed based on the parameters of the datatype. The expression denoting the type of the instance is computed by applying the name of the datatype to the bindings used the \lstmath{App} constructor. 

\begin{comment}
\subsection{Renaming}
\label{subsec:generation:renaming}
In multiple positions what we do is substitution, i.e. traverse the datatype and replace the occurence of one variable with another. 

\subsection{Bindings}
\label{subsec:generation:bindings}
Bindings are pervasive in definitions and are so important to deal with. We provide several utility functions for indexing bindings, repeating them, and other basic operations. 
The most interesting of all is the case when the bindings of two different entities need to be combined together, like in the case when both entities are arguments to a function.\ednote{Q: Is there literature on this?}  
\ednote{Q: How useful is the bindings section? Should I keep it?}
\end{comment}

\subsection{Prelude Definitions}
\label{subsec:generation:prelude}
The constructions that we defined here depends on some definitions that act as the prelude of the library. We declare these definitions as \lstmath{[String]} as follows: 
\begin{hscode}
nat :: [String]
nat =
  ("data Nat : Set where { " ++ 
     "zero : Nat ;" ++ 
     "suc  : Nat -> Nat }") : []
\end{hscode}
These strings are parsed by the function \lstmath{parseDecl}, wich turns it to a tog definition of type \lstmath{Decl}. 

%In order to develop a meta program that generates the constructions above, and possible more, we need a way to manipulate theory presentations, i.e. a program that given a theory presentation would generate theories, types, and functions representing the constructions above. Therefore, the program 
%equality, substitution, .. 

\section{Generated Constructions}
\label{sec:generatedConstructions}
By providing the appropriate tools to operate over the internal syntax of tog, we are ready to generate the universal algebra constructions related to equational theory presentations. In the following sections we describe the generation of these constructions. 

\subsection{Signature}
Signatures represent the language of the theory, without any properties governing them. It is common in mathematics to talk about algebras over some signature. Signatures are obtained from theory presentations by dropping axioms. In tog, the process of generating the signature is done in $3$ steps via the \lstmath{signature_} function. 
\begin{hscode}
signature_ :: Eq.EqTheory -> Eq.EqTheory
signature_ = over Eq.thyName (++ "Sig") . set Eq.axioms [] .  gmap ren
\end{hscode}
First, one need to rename the fields of the theory, to be able to use them in the signature definition. This is because the tog scope checker would not accept overloaded names of fields within the same module. The \lstmath{gmap ren} part of the function definition traverses the \lstmath{EqTheory} renaming fields by adding a suffix \lstmath{S} to each of them. In case the code is exported into a system that support this kind of overloading, the suffix can be removed. Note that this rename will be needed when generating any new construction. 
Next, the \lstmath{Eq.axioms} list is set to be empty, dropping the axioms of the theory. 
Last, The name of the signature of a theory \lstmath{t} is set to be \lstmath{tSig}. 

\subsection{Product Algebra} 
Product algebras group together algebras of the same theories. 
For a theory \lstmath{t}, the theory \lstmath{tProd} representing its product lifts every type \lstmath{A} to a type \lstmath{Prod A A}, where \lstmath{Prod} is standard product type. 
\begin{comment}
\begin{togcode}
Prod (A : Set) (B : Set) : Set
  constructor prodC
  field
   fst : A 
   snd : B  
\end{togcode}
\end{comment}
The lifting of the type \lstmath{A} is done via substitution of every \lstmath{A} with \lstmath{Prod A A}. 
The function \lstmath{productThry} uses this type to compute the product theory 
\begin{hscode}
  over Eq.thyName (++ "Prod") ~$\$$~
  over Eq.funcTypes (map mkProd) ~$\$$~
  over Eq.axioms (map mkProd)
  t'
\end{hscode}
\lstmath{t'} is isomorphic to the input theory and is obtained by adding suffix \lstmath{P} to the fields of the theory. The \lstmath{mkPord} function does the type lifting for the sort. 

\subsection{Homomorphism}
Theories are presented as record declarations in tog, and so are their homomorphisms. To generate homomorphism one needs to first define instances of the theory. We use the \lstmath{eqInstance} function to get those instances with the three components; the name of the instance, a list of bindings that represent arguments of the theory, and an expression representing the type of instances of the theory. 
\begin{hscode}
 i1@(n1,b1,e1) = Eq.eqInstance thry (Just 1) 
\end{hscode} 
with the second instance replacing every $1$ with $2$. 
The parameters of the homomorphism declaration is then created by appending the bindings of the first and second instances, and creating the instance declarations as  
\begin{hscode} 
 map (~$\backslash$~(n,e) -> Bind [mkArg n] e) [(n1,e1),(n2,e2)])
\end{hscode} 
The declarations of the homomorphism record are the homomorphism function and the preservation axioms. The function is generated by \lstmath{genHomFunc}. The function \lstmath{projConstr} is used to project the carriers of the instances and generate the type of the homomorphism function as follows 
\begin{hscode} 
Fun (Eq.projectConstr thry i1 carrier) (Eq.projectConstr thry i2 carrier)
\end{hscode}  
where \lstmath{i1} and \lstmath{i2} are the instances, \lstmath{thry} is the variable representing the equational theory and \lstmath{carrier} is the field in the theory representing the sort. 

Equations of the preservation axioms are generated by the \lstmath{equation} function. It uses \lstmath{applyProjConstr}, explained in~\ednote{put the ref}, which given an instance and a field, would generate the expression representing the application of the projected field from the instance, as well as the bindings needed for this application. 
\begin{hscode} 
(bind1,expr1) = Eq.applyProjConstr thry i1 constr Nothing
     (_,expr2) = Eq.applyProjConstr thry i2 constr Nothing 
\end{hscode} 
These pieces are used to construct the \lstmath{Pi}-type as follows 
\begin{hscode}
Pi (Tel bind1) ~$\$$~ Eq (lhs homFunc expr1) (rhs homFunc expr2)
\end{hscode} 

\subsection{Relational Interpretation}
\label{sec:generation:relInterp}
A relational interpretation is a structure preserving relation. Its implementation looks very similar to that of homomorphism -- a structure preserving function. Some of the similarities are that they are both records, and have the same parameters. However the fields are different. Instead of having a function between the two carriers, we have a relation. To generate the type of the relation field, we use the same function \lstmath{projectConstr} as follows 
\begin{hscode} 
Fun (Eq.projectConstr thry i1 carrier) ~$\$$~ 
     Fun (Eq.projectConstr thry i2 carrier) setTypeAsId
\end{hscode} 
Then we generate the axioms that guarantees preserving structure. For a binary operation, this axiom would look as follows 
\begin{lstlisting} [mathescape]
 interp-op : {x1 x2 : A1} {y1 y2 : A2} $\to$ 
           interp x1 y1 $\to$  interp x2 y2 $\to$ 
           interp (op x1 x2) (op y1 y2)
\end{lstlisting}
By using \lstmath{applyProjConstr} as is done in the generation of homomorphism, we get the two expressions \lstmath{op x1 x2} and \lstmath{op y1 y2} along with their bindings. 
\begin{hscode}  
 (bind1,expr1) = Eq.applyProjConstr thry i1 constr (Just 'x')
 (bind2,expr2) = Eq.applyProjConstr thry i2 constr (Just 'y')
\end{hscode} 
we make sure they use different names for the bindings by sending the variables names \lstmath{x} and \lstmath{y}. 
We create lists for the argumetns and the expressions as follows 
\begin{hscode} 
 args1 = concatMap getBindingArgs bind1 ++ [Arg expr1] 
 args2 = concatMap getBindingArgs bind2 ++ [Arg expr2]
\end{hscode} 
which generates lists \lstmath{[x1,x2,op x1 x2]} and \lstmath{[y1,y2,op y1 y2]}, which we align to generate the interpretation axiom as follows 
\begin{hscode} 
 zipWith (\x y -> App [mkArg (interpName ^. name),x,y]) args1 args2 
\end{hscode}

\input{term-algebra.tex}

\section{Discussion}
\label{sec:generation:discussion}
%We have introduced many constructions that can be derived from a theory presentation and implemented a framework in which we generate some of them. 

Knowledge representation is a key part of a generation framework. Our representation of \lstmath{EqTheory} follows from the axiomatic representation of algebraic structures as presented in universal algebra. The definitions of \lstmath{FType} and \lstmath{DType} corresponds to the representation of functions and datatype, respectively, in tog. Less obvious was the representations of instances \lstmath{EqInstance} and \lstmath{DTInstance} and function application. 
Once the knowledge capture and utility functions presented in Section~\ref{sec:togFamework} are in place, generating new constructions becomes a straight forward task. 
%Given a tog dependent record, we have generated multiple constructions; some of which are records, like signatures, products, and homomorphisms, some are datatypes, like the different forms of term langauges, and others are functions, like all the utility functions for term languages. 
%Another interesting problem here is related to dealing with bindings of two different inputs, how to determine if they are the same, different, hidden or explicit. 

Another useful lesson we learn here is about the importance of having a strong and small core language for manipulating structures. Many things were easy to do in tog because it is a small system. But we also faced difficulties due to the immaturity of some features in tog, like handling hidden arguments and passing constructors to functions. 

Using this framework we are able to generate a library of $106468$ lines of code from the representation of $227$ theories. Appendix~\ref{appendix:generatedTog} shows the generated definition for \lstmath{Monoid} theory. All the generated files are present on github under~\url{https://github.com/ysharoda/tog/blob/master/Library/mathscheme-generated.tog}. 
 
